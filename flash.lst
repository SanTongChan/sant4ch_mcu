C51 COMPILER V9.01   FLASH                                                                 07/17/2017 15:00:20 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN flash.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\flash\flash.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\flash.lst) OBJECT
                    -(flash.obj)

line level    source

   1          #include "flash.h"
   2          #include <stdio.h>
   3          #include "N76E003.h"
   4          #include "typedef.h"
   5          
   6          #if 0
              bit BIT_TMP;
              #define set_IAPEN   BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON|=0x01 ;EA=BIT_TMP;
              #define set_APUEN   BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;IAPUEN|=0x01;EA=BIT_TMP
              #define set_IAPGO   BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;IAPTRG|=0x01 ;EA=BIT_TMP
              #define clr_APUEN   BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;IAPUEN&=~0x01;EA=BIT_TMP
              #define clr_IAPEN   BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON&=~0x01;EA=BIT_TMP;
              
              uint8_t read_APROM_BYTE(uint16_t code *u16_addr)
              {
                      uint8_t rdata;
                      rdata = *u16_addr>>8;
                      return rdata;
              }
              
              void write_DATAFLASH_BYTE(uint16_t u16_addr,uint8_t u8_data)
              {
                      uint8_t looptmp=0,u8_addrl_r;
                      uint16_t code *cd_longaddr;
                      unsigned char xdata *xd_tmp;
                      
              //Check page start address
                      u8_addrl_r = u16_addr;
                      if (u8_addrl_r<0x80)
                      {
                              u8_addrl_r = 0;
                      }
                      else 
                      {
                              u8_addrl_r = 0x80;
                      }
              //Save APROM data to XRAM
                      xd_tmp = 0x80;
                      cd_longaddr = (uint16_t code*)((u16_addr&0xff00)+u8_addrl_r);   
                      while (xd_tmp !=0x100)
                      {
                              *xd_tmp = (uint8_t)(*cd_longaddr);
                              looptmp++;
                              xd_tmp++;
                              cd_longaddr++;
                      }
              // Modify customer data in XRAM
                      u8_addrl_r = u16_addr;
                      if (u8_addrl_r<0x80)
                      {
                              xd_tmp = u8_addrl_r+0x80;
                      }
                      else
C51 COMPILER V9.01   FLASH                                                                 07/17/2017 15:00:20 PAGE 2   

                      {
                              xd_tmp = u8_addrl_r+0;
                      }
                      *xd_tmp = u8_data;
              //Erase APROM DATAFLASH page
                  IAPAL = u16_addr;
                  IAPAH = u16_addr>>8;
                  IAPFD = 0xFF;
                  set_IAPEN; 
                  set_APUEN;
                  IAPCN = 0x22;               
                  set_IAPGO; 
              //Save changed RAM data to APROM DATAFLASH
                      u8_addrl_r = u16_addr;
                      if (u8_addrl_r<0x80)
                      {
                              u8_addrl_r =0;
                      }
                      else
                      {
                              u8_addrl_r = 0x80;
                      }
                  xd_tmp = 0x80;
                  IAPAL = u8_addrl_r;
                  IAPAH = u16_addr>>8;
                  set_IAPEN; 
                  set_APUEN;
                  IAPCN = 0x21;
                  while (xd_tmp !=0xFF)
                  {
                      IAPFD = *xd_tmp;
                      set_IAPGO;
                      IAPAL++;
                      xd_tmp++;
                  }
                  clr_APUEN;
                  clr_IAPEN;
              }       
              #endif
  93          
  94          #define PAGE_ERASE_AP  (0X22)
  95          #define BYTE_PROGRAM_AP (0x21)
  96          uint8_t xdata flash_data[FLASH_MAX_LEN] = {0xff};
  97          
  98          static void flashEnableAprom(void)
  99          {
 100   1              TA = 0xAA; //CHPCON is TA protected
 101   1              TA = 0x55;
 102   1              CHPCON |= 0x01; //IAPEN = 1, enable IAP mode
 103   1              TA = 0xAA; //IAPUEN is TA protected
 104   1              TA = 0x55;
 105   1              IAPUEN |= 0x01; //APUEN = 1, enable APROM update
 106   1      }
 107          
 108          
 109          static void flashErase(void)
 110          {
 111   1              IAPCN = PAGE_ERASE_AP; //Erase page 
 112   1              IAPAH = 0x38;
 113   1              IAPAL = 0x00;
 114   1              IAPFD = 0xFF;
 115   1              TA = 0xAA; //IAPTRG is TA protected
C51 COMPILER V9.01   FLASH                                                                 07/17/2017 15:00:20 PAGE 3   

 116   1              TA = 0x55;
 117   1              IAPTRG |= 0x01; //write ¡®1¡¯ to IAPGO to trigger IAP process
 118   1      }
 119          
 120          static void flashDisableAprom(void)
 121          {
 122   1              TA = 0xAA; //IAPUEN is TA protected
 123   1              TA = 0x55;
 124   1              IAPUEN &= ~0x01; //APUEN = 0, disable APROM update
 125   1              TA = 0xAA; //CHPCON is TA protected
 126   1              TA = 0x55;
 127   1              CHPCON &= ~0x01; //IAPEN = 0, disable IAP mode  
 128   1      }
 129          
 130          static void flashWriteBytes(void)
 131          {
 132   1      #if 1
 133   1              uint8_t i = 0;  
 134   1              for(i = 0; i < FLASH_MAX_LEN; i++)
 135   1              {
 136   2                      IAPCN = BYTE_PROGRAM_AP;
 137   2                      IAPAH = 0X38;
 138   2                      IAPAL = i;
 139   2                      IAPFD = flash_data[i];
 140   2                      TA = 0XAA;
 141   2                      TA = 0X55;
 142   2                      IAPTRG |= 0X01;
 143   2              }       
 144   1      #endif
 145   1      }
 146          void flashRead(void)
 147          {
 148   1              unsigned char i = 0;
 149   1              for(i = 0; i < FLASH_MAX_LEN; i++)
 150   1              {
 151   2                      flash_data[i] = *(uint16_t code *)(0x3800 + i)>>8;
 152   2                      //flash_data[i] = Data_Flash[i];
 153   2              }               
 154   1      }
 155          
 156          
 157          void flashWrite(void)
 158          {
 159   1              flashEnableAprom();
 160   1              flashErase();
 161   1              flashWriteBytes();
 162   1              flashDisableAprom();    
 163   1      }
 164          
 165          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    142    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
