C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 15:00:13 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          bool key_scan_flag = false;
  13          bool update_status_flag = false;
  14          bool led_blink_flag = false;
  15          bool deal_relay = false;
  16          DevDef dev_def = {0};
  17          uint16_t jogging_cnt = 0;
  18          static void h595Init(void)
  19          {
  20   1          //初始化P16 P17 P30为推挽输出
  21   1          P1M1 &= 0x3f;
  22   1              P1M2 |= 0Xc0;
  23   1              P3M1 &= 0xfe;
  24   1          P3M2 |= 0x01;
  25   1          SER = 1;
  26   1      }
  27          static void relayInit(void)
  28          {
  29   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  30   1              P0M2 &= 0Xf0;  
  31   1      }
  32          static void updateDeviceStatus(void)
  33          {
  34   1      #if 0
                  uint8_t temp = 0;
                  temp = (((uint8_t)RELAY1 << 7) | ((uint8_t)RELAY2 << 6) | ((uint8_t)RELAY3 << 5) | ((uint8_t)RELAY4 <<
             - 4));
                  if((temp & 0xf0) != (h595_val & 0xf0))
                  {
                      h595_val = ((h595_val & 0x0f) | (temp & 0xf0));
                      SendTo595(h595_val);
                  }
              #endif
  43   1          uint8_t last_val = 0;
  44   1          last_val = h595_val;
  45   1          if((((uint8_t)RELAY1 << 7) != (h595_val & RELAY1_595)) && (!dev_def.dev_channel[0].update_flag))
  46   1          {
  47   2              h595_val &= (~RELAY1_595);
  48   2              h595_val |= ((uint8_t)RELAY1 << 7);
  49   2          }
  50   1          if((((uint8_t)RELAY2 << 6) != (h595_val & RELAY2_595)) && (!dev_def.dev_channel[1].update_flag))
  51   1          {
  52   2              h595_val &= (~RELAY2_595);
  53   2              h595_val |= ((uint8_t)RELAY2 << 6);
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 15:00:13 PAGE 2   

  54   2          }
  55   1          if((((uint8_t)RELAY3 << 5) != (h595_val & RELAY3_595)) && (!dev_def.dev_channel[2].update_flag))
  56   1          {
  57   2              h595_val &= (~RELAY3_595);
  58   2              h595_val |= ((uint8_t)RELAY3 << 5);
  59   2          }
  60   1          if((((uint8_t)RELAY4 << 4) != (h595_val & RELAY4_595)) && (!dev_def.dev_channel[3].update_flag))
  61   1          {
  62   2              h595_val &= (~RELAY4_595);
  63   2              h595_val |= ((uint8_t)RELAY4 << 4);
  64   2          }
  65   1          if(last_val != h595_val)
  66   1          {
  67   2              SendTo595(h595_val);
  68   2          }
  69   1      }
  70          static void dealRealy(void)
  71          {
  72   1          //static bool lock = false;
  73   1          uint8_t relay_array[4] = {0x80,0x40,0x20,0x10};
  74   1          uint8_t key_array[4] = {0x04,0x02,0x01,0x08};
  75   1          uint8_t relays[4] = {0};
  76   1          uint8_t i = 0;
  77   1          uint8_t last_val = 0;
  78   1          relays[0] = (uint8_t)RELAY1;
  79   1          relays[1] = (uint8_t)RELAY2;
  80   1          relays[2] = (uint8_t)RELAY3;
  81   1          relays[3] = (uint8_t)RELAY4;
  82   1      
  83   1          jogging_cnt++;
  84   1          last_val = h595_val;
  85   1          if(!dev_def.lock)
  86   1          {
  87   2              for(i =  0; i < 4; i++)
  88   2              {
  89   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
  90   3                  {
  91   4                      dev_def.dev_channel[i].timer_cnt++;
  92   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
  93   4                      {
  94   5                          if(dev_def.dev_channel[i].get_status == false)
  95   5                          {
  96   6                              dev_def.dev_channel[i].timer_cnt = 0;
  97   6                              dev_def.dev_channel[i].get_status = true;
  98   6                          }
  99   5                          if(dev_def.dev_channel[i].timer_cnt >= 100)
 100   5                          {
 101   6                              dev_def.dev_channel[i].timer_cnt = 0;
 102   6                              dev_def.dev_channel[i].get_status = false;
 103   6                              h595_val &= (~relay_array[i]);//关掉relay1
 104   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 105   6                              jogging_cnt = 0;
 106   6                          }
 107   5                      }
 108   4                      else
 109   4                      {
 110   5                          dev_def.dev_channel[i].timer_cnt = 0;
 111   5                          if(relays[i] == 0 && dev_def.dev_channel[i].update_flag == true)
 112   5                          {
 113   6                              h595_val |= key_array[i];
 114   6                              dev_def.dev_channel[i].update_flag = false;
 115   6                          }
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 15:00:13 PAGE 3   

 116   5                      }
 117   4                  }
 118   3              }
 119   2              if(jogging_cnt == 50)
 120   2              {
 121   3                  for (i = 0; i < 4; i++)
 122   3                  {
 123   4                      if((dev_def.dev_channel[i].update_flag == true) 
 124   4                          && ((h595_val & key_array[i]))
 125   4                          && (!dev_def.dev_channel[i].lock))
 126   4                      {
 127   5                          h595_val &= ~key_array[i];
 128   5                      }
 129   4                  }
 130   3              }
 131   2              else if(jogging_cnt == 60)
 132   2              {
 133   3                  for(i = 0; i < 4; i++)
 134   3                  {
 135   4                      if((dev_def.dev_channel[i].update_flag == true)
 136   4                          && ((h595_val & key_array[i]) == 0)
 137   4                          && (!dev_def.dev_channel[i].lock))
 138   4                      {
 139   5                          MODE_LED = 1;
 140   5                          h595_val |= key_array[i];
 141   5                          dev_def.dev_channel[i].lock = true;
 142   5                      }
 143   4                  }
 144   3              }
 145   2              for(i = 0; i < 4; i++)
 146   2              {
 147   3                  if((relays[i] << (7 - i)) == (h595_val & relay_array[i])
 148   3                      && dev_def.dev_channel[i].lock == true)
 149   3                  {
 150   4                      dev_def.dev_channel[i].lock = false;
 151   4                      dev_def.dev_channel[i].update_flag = false;
 152   4                  }
 153   3              }
 154   2          }
 155   1          if(last_val != h595_val)
 156   1          {
 157   2              SendTo595(h595_val);
 158   2          }
 159   1       #if 0
                  jogging_cnt++;
                  if(!dev_def.lock)
                  {
                      if(dev_def.dev_channel[0].channel_mode == DEV_JOGGING)
                      {
                          dev_def.dev_channel[0].timer_cnt++;
                          if((h595_val & RELAY1_595))//如果relay1是按下的
                          {
                              if(dev_def.dev_channel[0].get_status == false)
                              {
                                  dev_def.dev_channel[0].timer_cnt = 0;
                                  dev_def.dev_channel[0].get_status = true;
                              }
                              if(dev_def.dev_channel[0].timer_cnt >= 100)
                              {
                                  dev_def.dev_channel[0].timer_cnt = 0;
                                  dev_def.dev_channel[0].get_status = false;
                                  h595_val &= (~RELAY1_595);//关掉relay1
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 15:00:13 PAGE 4   

                                  dev_def.dev_channel[0].update_flag = true;//允许更新标志位
                                  jogging_cnt = 0;
                              }
                          }
                          else
                          {
                              dev_def.dev_channel[0].timer_cnt = 0;
                              if(RELAY1 == 0 && dev_def.dev_channel[0].update_flag == true)
                              {
                                  h595_val |= KEY1_595;
                                  dev_def.dev_channel[0].update_flag = false;
                              }
                          }
                          if(jogging_cnt == 50)
                          {
                              if(dev_def.dev_channel[0].update_flag == true)
                              {
                                  h595_val &= ~KEY1_595;
                              }
                          }
                          else if(jogging_cnt > 60 && jogging_cnt <= 70)
                          {
                              if(dev_def.dev_channel[0].update_flag == true)
                              {
                                  if((h595_val & KEY1_595) == 0)
                                  {
                                       h595_val |= KEY1_595;
                                  }
                              }
                          }
                          else if(jogging_cnt > 70)
                          {
                              if(((uint8_t)RELAY1 << 7) == (h595_val & RELAY1_595))
                              {
                                  jogging_cnt = 0;
                                  dev_def.dev_channel[0].update_flag = false;
                              }
                          }
                      }
                      /*
                      else
                      {
                          if((h595_val & KEY1_595) || dev_def.dev_channel[0].update_flag)
                          {
                              h595_val |= KEY1_595;
                              dev_def.dev_channel[0].update_flag = false;
                          }
                      }
                      */
                      SendTo595(h595_val);
                  }
                  else
                  {
              
                  }
              #endif
 234   1      }
 235          void dealLogic(void)
 236          {
 237   1          if(key_scan_flag)
 238   1          {
 239   2              key_scan_flag = false;
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 15:00:13 PAGE 5   

 240   2              keyScan();
 241   2          }
 242   1          
 243   1          if(deal_relay)
 244   1          {
 245   2              dealRealy();
 246   2              deal_relay = false;
 247   2          }
 248   1          if(update_status_flag)
 249   1          {
 250   2              updateDeviceStatus();
 251   2              update_status_flag = false;
 252   2          }
 253   1      }
 254          void logicInit(void)
 255          {
 256   1          h595Init();
 257   1          SendTo595(0x0f);
 258   1          ledInit();   
 259   1              keyInit();
 260   1          relayInit();
 261   1          timer0Init();
 262   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 263   1          dev_def.dev_channel[1].channel_mode = DEV_JOGGING;
 264   1          dev_def.dev_channel[2].channel_mode = DEV_JOGGING;
 265   1          dev_def.dev_channel[3].channel_mode = DEV_JOGGING;
 266   1          MODE_LED = 0;
 267   1      }
 268          void SendTo595(uint8_t val)
 269          {
 270   1              char i=0;
 271   1              uint8_t temp = val;
 272   1              EA = 0;
 273   1              for(i = 0; i < 8; i++)
 274   1              {
 275   2                      SER = temp>>7;
 276   2                      temp= temp<<1;
 277   2                      SCK = 0;
 278   2                      _nop_();
 279   2                      SCK = 1;
 280   2              }
 281   1              RCK = 0;
 282   1              _nop_();
 283   1              RCK = 1;
 284   1              SER = 0;
 285   1              EA = 1;
 286   1      }
 287          
 288          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    780    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
