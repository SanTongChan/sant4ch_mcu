C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT
                    -(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          #include "flash.h"
   9          #include "remote.h"
  10          
  11          sbit RCK = P1^7;
  12          sbit SCK = P1^6;
  13          sbit SER = P3^0;
  14          
  15          bool key_scan_flag = false;
  16          bool update_local_flag = false;
  17          bool syn_app_flag = false;
  18          bool save_mode_flag = false;
  19          bool deal_remote_flag = false;
  20          bool remote_led_study = false;
  21          uint8_t remote_led_blink = 0;
  22          uint8_t update_time = 5;
  23          
  24          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  25          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  26          
  27          DevDef xdata dev_def = {0};
  28          static void h595Init(void)
  29          {
  30   1          //初始化P16 P17 P30为推挽输出
  31   1          P1M1 &= 0x3f;
  32   1              P1M2 |= 0Xc0;
  33   1              P3M1 &= 0xfe;
  34   1          P3M2 |= 0x01;
  35   1          SER = 1;
  36   1      }
  37          static void relayInit(void)
  38          {
  39   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  40   1              P0M2 &= 0Xf0;  
  41   1      }
  42          static void syncApp(void)
  43          {
  44   1          uint8_t last_key = h595_val;
  45   1          uint8_t relays[4] = {0};
  46   1          uint8_t i = 0;
  47   1          relays[0] = RELAY1;
  48   1          relays[1] = RELAY2;
  49   1          relays[2] = RELAY3;
  50   1          relays[3] = RELAY4;
  51   1          if(dev_def.lock)
  52   1          {
  53   2              static uint8_t lock_channel = 0;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 2   

  54   2              static uint8_t last_lock_channel = 0;
  55   2              static uint8_t last_relay_val[4] = {0};
  56   2              if(dev_def.dev_channel[0].update_flag 
  57   2                  || dev_def.dev_channel[1].update_flag 
  58   2                  || dev_def.dev_channel[2].update_flag
  59   2                  || dev_def.dev_channel[3].update_flag)
  60   2              {
  61   3                  return;
  62   3              }
  63   2              for(i = 0; i < 4;i++)
  64   2              {
  65   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  66   3                  {
  67   4                      lock_channel = i + 1;
  68   4                  }
  69   3                  last_relay_val[i] = relays[i];
  70   3              }
  71   2              if(last_lock_channel != lock_channel)
  72   2              {
  73   3                  last_lock_channel = lock_channel;
  74   3                  for(i = 0; i < 4; i++)
  75   3                  {
  76   4                      if(lock_channel == (i + 1))
  77   4                      {
  78   5                          h595_val &= 0x0f;
  79   5                          h595_val |= relay_array[i];
  80   5                      }
  81   4                  }
  82   3                  dev_def.dev_channel[0].update_flag = true;
  83   3                  dev_def.dev_channel[1].update_flag = true;
  84   3                  dev_def.dev_channel[2].update_flag = true;
  85   3                  dev_def.dev_channel[3].update_flag = true;
  86   3                  dev_def.update_local_cnt = 0;
  87   3                  dev_def.setting = false;
  88   3                  update_time = 5;
  89   3              }
  90   2              else
  91   2              {
  92   3                  if(relays[lock_channel - 1])
  93   3                  {
  94   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  95   4                      {
  96   5                          h595_val |= relay_array[lock_channel - 1];
  97   5                          dev_def.dev_channel[0].update_flag = true;
  98   5                          dev_def.dev_channel[1].update_flag = true;
  99   5                          dev_def.dev_channel[2].update_flag = true;
 100   5                          dev_def.dev_channel[3].update_flag = true;
 101   5                          dev_def.update_local_cnt = 0;
 102   5                          dev_def.setting = false;
 103   5                          update_time = 5;
 104   5                      }
 105   4                     
 106   4                  }
 107   3                  else
 108   3                  {
 109   4                      if(h595_val & relay_array[lock_channel - 1])
 110   4                      {
 111   5                          h595_val &= ~relay_array[lock_channel - 1];
 112   5                          dev_def.dev_channel[0].update_flag = true;
 113   5                          dev_def.dev_channel[1].update_flag = true;
 114   5                          dev_def.dev_channel[2].update_flag = true;
 115   5                          dev_def.dev_channel[3].update_flag = true;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 3   

 116   5                          dev_def.update_local_cnt = 0;
 117   5                          dev_def.setting = false;
 118   5                          update_time = 5;
 119   5                      }
 120   4                  }
 121   3              }
 122   2          }
 123   1          else
 124   1          {
 125   2              for(i =  0; i < 4; i++)
 126   2              {
 127   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 128   3                  {
 129   4                      dev_def.dev_channel[i].timer_cnt++;
 130   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 131   4                      {
 132   5                          if(dev_def.dev_channel[i].get_status == false)
 133   5                          {
 134   6                              dev_def.dev_channel[i].timer_cnt = 0;
 135   6                              dev_def.dev_channel[i].get_status = true;
 136   6                          }
 137   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 138   5                          {
 139   6                              dev_def.dev_channel[i].timer_cnt = 0;
 140   6                              dev_def.dev_channel[i].get_status = false;
 141   6                              h595_val &= (~relay_array[i]);//关掉relay1
 142   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 143   6                              dev_def.update_local_cnt = 0;
 144   6                              dev_def.setting = false;
 145   6                              update_time = 5;
 146   6                          }
 147   5                      }
 148   4                  }
 149   3                  if(!dev_def.dev_channel[i].update_flag)
 150   3                  {
 151   4                      if(relays[i])
 152   4                      {
 153   5                          h595_val |= relay_array[i];
 154   5                      }
 155   4                      else
 156   4                      {
 157   5                          h595_val &= (~relay_array[i]);
 158   5                      }
 159   4                  }
 160   3              }
 161   2          }
 162   1          if(h595_val != last_key)
 163   1          {
 164   2              SendTo595(h595_val);
 165   2          }
 166   1      }
 167          static void updateLocal(void)
 168          {
 169   1          static bool high_flag[4] = {false};
 170   1          uint8_t i = 0;
 171   1          uint8_t last_key = h595_val;
 172   1          uint8_t relays[4] = {0};
 173   1          dev_def.update_local_cnt++;
 174   1          if(dev_def.update_local_cnt == update_time)
 175   1          {
 176   2              relays[0] = (uint8_t)RELAY1;
 177   2              relays[1] = (uint8_t)RELAY2;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 4   

 178   2              relays[2] = (uint8_t)RELAY3;
 179   2              relays[3] = (uint8_t)RELAY4;
 180   2              for(i = 0; i < 4; i++)
 181   2              {
 182   3                  if(dev_def.dev_channel[i].update_flag)
 183   3                  {
 184   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 185   4                      {
 186   5                          high_flag[i] = true;
 187   5                          h595_val &= ~key_array[i];
 188   5                      }
 189   4                      else
 190   4                      {
 191   5                          dev_def.dev_channel[i].update_flag = false;
 192   5                      }
 193   4                  }
 194   3              }
 195   2              if(h595_val != last_key)
 196   2              {
 197   3                  SendTo595(h595_val);
 198   3              }
 199   2          }
 200   1          else if(dev_def.update_local_cnt >= update_time + 1)
 201   1          {
 202   2              dev_def.update_local_cnt = 0;
 203   2              for(i = 0; i < 4; i++)
 204   2              {
 205   3                  if(high_flag[i] == true)
 206   3                  {
 207   4                      h595_val |= key_array[i];
 208   4                      high_flag[i] = false;
 209   4                  }
 210   3              }
 211   2              if(h595_val != last_key)
 212   2              {
 213   3                  SendTo595(h595_val);
 214   3              }
 215   2          }
 216   1      
 217   1          
 218   1      }
 219          void dealLogic(void)
 220          {
 221   1          if(key_scan_flag)
 222   1          {
 223   2              key_scan_flag = false;
 224   2              keyScan();
 225   2          }
 226   1          if(syn_app_flag)
 227   1          {
 228   2              syn_app_flag = false;
 229   2              syncApp();
 230   2          }
 231   1          if(update_local_flag)
 232   1          {
 233   2              update_local_flag = false;
 234   2              updateLocal();//要在同步APP之后
 235   2          }
 236   1      }
 237          void saveModeToFlash(void)
 238          {
 239   1          if(save_mode_flag)
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 5   

 240   1          {
 241   2                      flash_data[0] = dev_def.lock;
 242   2                      flash_data[1] = (uint8_t)dev_def.dev_channel[0].channel_mode;
 243   2                      flash_data[2] = (uint8_t)dev_def.dev_channel[1].channel_mode;
 244   2                      flash_data[3] = (uint8_t)dev_def.dev_channel[2].channel_mode;
 245   2                      flash_data[4] = (uint8_t)dev_def.dev_channel[3].channel_mode;
 246   2                      flash_data[5] = (uint8_t)(dev_def.dev_channel[0].remote_val >> 16);
 247   2                      flash_data[6] = (uint8_t)(dev_def.dev_channel[0].remote_val >> 8);
 248   2                      flash_data[7] = (uint8_t)dev_def.dev_channel[0].remote_val;
 249   2                      flash_data[8] = (uint8_t)(dev_def.dev_channel[1].remote_val >> 16);
 250   2                      flash_data[9] = (uint8_t)(dev_def.dev_channel[1].remote_val >> 8);
 251   2                      flash_data[10] = (uint8_t)dev_def.dev_channel[1].remote_val;
 252   2                      flash_data[11] = (uint8_t)(dev_def.dev_channel[2].remote_val >> 16);
 253   2                      flash_data[12] = (uint8_t)(dev_def.dev_channel[2].remote_val >> 8);
 254   2                      flash_data[13] = (uint8_t)dev_def.dev_channel[2].remote_val;
 255   2                      flash_data[14] = (uint8_t)(dev_def.dev_channel[3].remote_val >> 16);
 256   2                      flash_data[15] = (uint8_t)(dev_def.dev_channel[3].remote_val >> 8);
 257   2                      flash_data[16] = (uint8_t)dev_def.dev_channel[3].remote_val;
 258   2                      flashWrite();
 259   2                      save_mode_flag = false;
 260   2          }
 261   1      }
 262          static void dealRemoteModeLed(void)
 263          {
 264   1          static uint8_t remote_led_cnt = 0;
 265   1          remote_led_cnt++;
 266   1          if(dev_def.remote)
 267   1              {
 268   2              if(remote_led_cnt >= 100)
 269   2              {
 270   3                  remote_led_cnt = 0;
 271   3                  MODE_LED = !MODE_LED;
 272   3              }
 273   2              }
 274   1              else
 275   1              {
 276   2              if(dev_def.lock)
 277   2              {
 278   3                  MODE_LED = 1;
 279   3              }
 280   2              else
 281   2              {
 282   3                  MODE_LED = 0;
 283   3              }
 284   2              }
 285   1      }
 286          void dealRemoteStudyLed(void)
 287          {
 288   1          static uint8_t cnt = 0;
 289   1          cnt++;
 290   1          if(cnt >= 100 && remote_led_study)
 291   1          {
 292   2              cnt = 0;
 293   2              if(RF_LED)
 294   2              {
 295   3                  RF_LED = 0;
 296   3                  remote_led_blink++;
 297   3              }
 298   2              else
 299   2              {
 300   3                  RF_LED = 1;
 301   3              }
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 6   

 302   2          }
 303   1          if((remote_led_blink >= 4) && remote_led_study)
 304   1          {
 305   2              RF_LED = 0;
 306   2              remote_led_blink = 0;
 307   2              remote_led_study = false;
 308   2          }
 309   1      }
 310          void dealRemoteNormalLed(void)
 311          {
 312   1          static uint8_t cnt = 0;
 313   1          cnt++;
 314   1          if(!dev_def.remote 
 315   1          && (ir_data.ir_data == dev_def.dev_channel[1].remote_val
 316   1          || ir_data.ir_data == dev_def.dev_channel[0].remote_val
 317   1          || ir_data.ir_data == dev_def.dev_channel[2].remote_val
 318   1          || ir_data.ir_data == dev_def.dev_channel[3].remote_val)
 319   1          )
 320   1          {
 321   2              if(ir_data.cnt > 0 && cnt >= 15)
 322   2              {
 323   3                  cnt = 0;
 324   3                  RF_LED = !RF_LED;
 325   3              }
 326   2              if(ir_data.timer_cnt >= 100)
 327   2              {
 328   3                  RF_LED = 0;
 329   3              }
 330   2          }
 331   1      }
 332          void dealRemoteLed(void)
 333          {
 334   1          dealRemoteModeLed();
 335   1              dealRemoteStudyLed();
 336   1              dealRemoteNormalLed();
 337   1      }
 338          void dealRemoteStudy(void)
 339          {
 340   1          if(dev_def.remote_channel != 0 && dev_def.remote)
 341   1          {
 342   2              if(ir_data.cnt == 10)
 343   2              {
 344   3                  remote_led_study = true;
 345   3                  remote_led_blink = 0;
 346   3                  RF_LED = 0;
 347   3              }
 348   2              if(ir_data.cnt >= 10 && ir_data.timer_cnt >= 150)
 349   2              {
 350   3                  //ir_data.cnt = 0;
 351   3                  dev_def.dev_channel[dev_def.remote_channel - 1].remote_val = ir_data.ir_data;
 352   3                  clearIrData();
 353   3                  dev_def.remote_channel = 0;
 354   3                  save_mode_flag = true;
 355   3              }
 356   2          }
 357   1      }
 358          void dealRemoteNormal(void)
 359          {
 360   1          static uint16_t cnt = 0;
 361   1          uint8_t i = 0;
 362   1              uint8_t relays[4] = {0};
 363   1          cnt++;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 7   

 364   1          if(!dev_def.remote)
 365   1          {
 366   2              relays[0] = RELAY1;
 367   2              relays[1] = RELAY2;
 368   2              relays[2] = RELAY3;
 369   2              relays[3] = RELAY4;
 370   2              if(ir_data.cnt == 1)
 371   2              {
 372   3                  for(i = 0; i < 4; i++)
 373   3                  {
 374   4                      if(ir_data.ir_data == dev_def.dev_channel[i].remote_val)
 375   4                      {
 376   5                          h595_val |= 0x0f;
 377   5                          h595_val &= (~key_array[i]);
 378   5                          dev_def.remote_channel = i;
 379   5                          SendTo595(h595_val);   
 380   5                          cnt = 0;
 381   5                      }
 382   4                  }
 383   3              }
 384   2              else if(ir_data.timer_cnt >= 150 && ir_data.cnt >= 1
 385   2              && ir_data.ir_data == dev_def.dev_channel[dev_def.remote_channel].remote_val)
 386   2              {
 387   3                  h595_val |= 0x0f;
 388   3                  if(cnt <= 2500)
 389   3                  {
 390   4                      if(relays[dev_def.remote_channel])
 391   4                      {
 392   5                          h595_val &= (~relay_array[dev_def.remote_channel]);    
 393   5                      }
 394   4                      else
 395   4                      {
 396   5                          if(dev_def.lock)
 397   5                          {
 398   6                              h595_val &= 0x0f;
 399   6                          }
 400   5                          h595_val |= relay_array[dev_def.remote_channel] ;
 401   5                      }
 402   4                      dev_def.remote_channel = 0;
 403   4                      dev_def.dev_channel[0].update_flag = true;
 404   4                      dev_def.dev_channel[1].update_flag = true;
 405   4                      dev_def.dev_channel[2].update_flag = true;
 406   4                      dev_def.dev_channel[3].update_flag = true;
 407   4                      dev_def.update_local_cnt = 0;
 408   4                      update_time = 10;
 409   4                  }
 410   3                  SendTo595(h595_val);
 411   3                  clearIrData();
 412   3              }
 413   2          }
 414   1      }
 415          void dealRemote(void)
 416          {
 417   1              if(deal_remote_flag)
 418   1              {
 419   2                      deal_remote_flag = false;
 420   2                      analyzeRfData();
 421   2                      dealRemoteLed();
 422   2                      dealRemoteStudy();
 423   2                      dealRemoteNormal();
 424   2              }
 425   1      }
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 8   

 426          static void modeInit(void)
 427          {
 428   1              flashRead();
 429   1              dev_def.lock = flash_data[0];
 430   1              dev_def.dev_channel[0].channel_mode = flash_data[1];
 431   1              dev_def.dev_channel[1].channel_mode = flash_data[2];
 432   1              dev_def.dev_channel[2].channel_mode = flash_data[3];
 433   1              dev_def.dev_channel[3].channel_mode = flash_data[4];
 434   1              dev_def.dev_channel[0].remote_val = 
 435   1                      (uint32_t)flash_data[5] << 16
 436   1                      | (uint32_t)flash_data[6] << 8 
 437   1                      | flash_data[7];
 438   1          dev_def.dev_channel[1].remote_val = 
 439   1                  (uint32_t)flash_data[8] << 16 
 440   1                  | (uint32_t)flash_data[9] << 8 
 441   1                  | flash_data[10];
 442   1          dev_def.dev_channel[2].remote_val = 
 443   1                  (uint32_t)flash_data[11] << 16 
 444   1                  | (uint32_t)flash_data[12] << 8 
 445   1                  | flash_data[13];
 446   1          dev_def.dev_channel[3].remote_val = 
 447   1                  (uint32_t)flash_data[14] << 16 
 448   1                  | (uint32_t)flash_data[15] << 8 
 449   1                  | flash_data[16];
 450   1          if(dev_def.lock == 0xff 
 451   1              || dev_def.dev_channel[0].channel_mode == 0xff
 452   1              || dev_def.dev_channel[1].channel_mode == 0xff
 453   1              || dev_def.dev_channel[2].channel_mode == 0xff
 454   1              || dev_def.dev_channel[3].channel_mode == 0xff
 455   1              || dev_def.dev_channel[0].remote_val == 0xffffff
 456   1              || dev_def.dev_channel[1].remote_val == 0xffffff
 457   1              || dev_def.dev_channel[2].remote_val == 0xffffff
 458   1              || dev_def.dev_channel[3].remote_val == 0xffffff)
 459   1          {
 460   2              dev_def.lock = false;
 461   2              dev_def.dev_channel[0].channel_mode = DEV_SELFLOCK;
 462   2              dev_def.dev_channel[1].channel_mode = DEV_SELFLOCK;
 463   2              dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 464   2              dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 465   2              dev_def.dev_channel[0].remote_val = 0x0;
 466   2              dev_def.dev_channel[1].remote_val = 0x0;
 467   2              dev_def.dev_channel[2].remote_val = 0x0;
 468   2              dev_def.dev_channel[3].remote_val = 0x0;
 469   2          }
 470   1          if(dev_def.lock)
 471   1          {
 472   2              MODE_LED = 1;
 473   2          }
 474   1          else
 475   1          {
 476   2              MODE_LED = 0;
 477   2          }
 478   1      }
 479          void logicInit(void)
 480          {
 481   1          modeInit();
 482   1          h595Init();
 483   1          SendTo595(0x0f);
 484   1          ledInit();   
 485   1              keyInit();
 486   1          relayInit();
 487   1      #if 1
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 23:00:20 PAGE 9   

 488   1              captureInit();
 489   1              timer1Init();
 490   1      #endif
 491   1          timer0Init();
 492   1      }
 493          void SendTo595(uint8_t val)
 494          {
 495   1              char i=0;
 496   1              uint8_t temp = val;
 497   1              EA = 0;
 498   1              for(i = 0; i < 8; i++)
 499   1              {
 500   2                      SER = temp>>7;
 501   2                      temp= temp<<1;
 502   2                      SCK = 0;
 503   2                      _nop_();
 504   2                      SCK = 1;
 505   2              }
 506   1              RCK = 0;
 507   1              _nop_();
 508   1              RCK = 1;
 509   1              SER = 0;
 510   1              EA = 1;
 511   1      }
 512          
 513          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2452    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     41    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
