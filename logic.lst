C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          bool key_scan_flag = false;
  13          bool update_status_flag = false;
  14          bool led_blink_flag = false;
  15          bool deal_jogging = false;
  16          bool lock_flag = false;
  17          uint8_t relay_array[4] = {0x80,0x40,0x20,0x10};
  18          uint8_t key_array[4] = {0x04,0x02,0x01,0x08};
  19          
  20          DevDef dev_def = {0};
  21          uint16_t jogging_cnt = 0;
  22          static void h595Init(void)
  23          {
  24   1          //初始化P16 P17 P30为推挽输出
  25   1          P1M1 &= 0x3f;
  26   1              P1M2 |= 0Xc0;
  27   1              P3M1 &= 0xfe;
  28   1          P3M2 |= 0x01;
  29   1          SER = 1;
  30   1      }
  31          static void relayInit(void)
  32          {
  33   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  34   1              P0M2 &= 0Xf0;  
  35   1      }
  36          static void updateDeviceStatus(void)
  37          {
  38   1          uint8_t last_val = 0;
  39   1          if(!dev_def.lock)
  40   1          {
  41   2              last_val = h595_val;
  42   2              if((((uint8_t)RELAY1 << 7) != (h595_val & RELAY1_595)) && (!dev_def.dev_channel[0].update_flag))
  43   2              {
  44   3                  h595_val &= (~RELAY1_595);
  45   3                  h595_val |= ((uint8_t)RELAY1 << 7);
  46   3              }
  47   2              if((((uint8_t)RELAY2 << 6) != (h595_val & RELAY2_595)) && (!dev_def.dev_channel[1].update_flag))
  48   2              {   
  49   3                  h595_val = (~RELAY2_595);
  50   3                  h595_val |= ((uint8_t)RELAY2 << 6);
  51   3              }
  52   2              if((((uint8_t)RELAY3 << 5) != (h595_val & RELAY3_595)) && (!dev_def.dev_channel[2].update_flag))
  53   2              {
  54   3                  h595_val &= (~RELAY3_595);
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 2   

  55   3                  h595_val |= ((uint8_t)RELAY3 << 5);
  56   3              }
  57   2              if((((uint8_t)RELAY4 << 4) != (h595_val & RELAY4_595)) && (!dev_def.dev_channel[3].update_flag))
  58   2              {
  59   3                  h595_val &= (~RELAY4_595);
  60   3                  h595_val |= ((uint8_t)RELAY4 << 4);
  61   3              }
  62   2              if(last_val != h595_val)
  63   2              {
  64   3                  SendTo595(h595_val);
  65   3              }
  66   2          }
  67   1      }
  68          static void dealJogging(void)
  69          {
  70   1          uint8_t relays[4] = {0};
  71   1          uint8_t i = 0;
  72   1          uint8_t last_val = 0;
  73   1          if(!dev_def.lock)
  74   1          {
  75   2              jogging_cnt++;
  76   2              last_val = h595_val;
  77   2              relays[0] = (uint8_t)RELAY1;
  78   2              relays[1] = (uint8_t)RELAY2;
  79   2              relays[2] = (uint8_t)RELAY3;
  80   2              relays[3] = (uint8_t)RELAY4;
  81   2              for(i =  0; i < 4; i++)
  82   2              {
  83   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
  84   3                  {
  85   4                      dev_def.dev_channel[i].timer_cnt++;
  86   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
  87   4                      {
  88   5                          if(dev_def.dev_channel[i].get_status == false)
  89   5                          {
  90   6                              dev_def.dev_channel[i].timer_cnt = 0;
  91   6                              dev_def.dev_channel[i].get_status = true;
  92   6                          }
  93   5                          if(dev_def.dev_channel[i].timer_cnt >= 100)
  94   5                          {
  95   6                              dev_def.dev_channel[i].timer_cnt = 0;
  96   6                              dev_def.dev_channel[i].get_status = false;
  97   6                              h595_val &= (~relay_array[i]);//关掉relay1
  98   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
  99   6                              jogging_cnt = 0;
 100   6                          }
 101   5                      }
 102   4                      else
 103   4                      {
 104   5                          dev_def.dev_channel[i].timer_cnt = 0;
 105   5                          if(relays[i] == 0 && dev_def.dev_channel[i].update_flag == true)
 106   5                          {
 107   6                              h595_val |= key_array[i];
 108   6                              dev_def.dev_channel[i].update_flag = false;
 109   6                          }
 110   5                      }
 111   4                  }
 112   3              }
 113   2              if(jogging_cnt == 80)
 114   2              {
 115   3                  for (i = 0; i < 4; i++)
 116   3                  {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 3   

 117   4                      if((dev_def.dev_channel[i].update_flag == true) 
 118   4                          && ((h595_val & key_array[i]))
 119   4                          && (!dev_def.dev_channel[i].lock))
 120   4                      {
 121   5                          h595_val &= ~key_array[i];
 122   5                      }
 123   4                  }
 124   3              }
 125   2              else if(jogging_cnt == 100)
 126   2              {
 127   3                  for(i = 0; i < 4; i++)
 128   3                  {
 129   4                      if((dev_def.dev_channel[i].update_flag == true)
 130   4                          && ((h595_val & key_array[i]) == 0)
 131   4                          && (!dev_def.dev_channel[i].lock))
 132   4                      {
 133   5                          //MODE_LED = 1;
 134   5                          h595_val |= key_array[i];
 135   5                          dev_def.dev_channel[i].lock = true;
 136   5                      }
 137   4                  }
 138   3              }
 139   2              for(i = 0; i < 4; i++)
 140   2              {
 141   3                  if((relays[i] << (7 - i)) == (h595_val & relay_array[i])
 142   3                      && dev_def.dev_channel[i].lock == true)
 143   3                  {
 144   4                      dev_def.dev_channel[i].lock = false;
 145   4                      dev_def.dev_channel[i].update_flag = false;
 146   4                  }
 147   3              }    
 148   2              if(last_val != h595_val)
 149   2              {
 150   3                  SendTo595(h595_val);
 151   3              }
 152   2          }
 153   1      }
 154          static void dealLock(void)
 155          {
 156   1          static uint8_t lock_channel = 0;
 157   1          static uint8_t last_lock_channel = 0;
 158   1          static uint8_t last_relay_val[4] = {0};
 159   1          uint8_t relays[4] = {0};
 160   1          uint8_t i = 0;
 161   1          uint8_t last_val = h595_val;
 162   1          if(dev_def.lock)
 163   1          {
 164   2              dev_def.lock_cnt++;
 165   2              relays[0] = RELAY1;
 166   2              relays[1] = RELAY2;
 167   2              relays[2] = RELAY3;
 168   2              relays[3] = RELAY4;
 169   2              for(i = 0; i < 4;i++)
 170   2              {
 171   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
 172   3                  {
 173   4                      lock_channel = i + 1;
 174   4                  }
 175   3                  last_relay_val[i] = relays[i];
 176   3              }
 177   2              if(last_lock_channel != lock_channel)
 178   2              {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 4   

 179   3                  MODE_LED = !MODE_LED;
 180   3                  last_lock_channel = lock_channel;
 181   3                  for(i = 0; i < 4; i++)
 182   3                  {
 183   4                      if(relays[i] == 1 && lock_channel != (i + 1))
 184   4                      {
 185   5                          h595_val &= ~key_array[i];
 186   5                          h595_val &= ~relay_array[i];
 187   5                      }
 188   4                      else if(lock_channel == (i + 1))
 189   4                      {
 190   5                          if(relays[i])
 191   5                          {
 192   6                              if(!(h595_val & relay_array[i]))
 193   6                              {
 194   7                                  h595_val |= relay_array[i];
 195   7                              }
 196   6                          }
 197   5                      }
 198   4                  }
 199   3                  dev_def.lock_cnt = 0;
 200   3                  dev_def.lock_update = true;
 201   3              }
 202   2              else
 203   2              {
 204   3                  
 205   3                  if(relays[lock_channel - 1])
 206   3                  {
 207   4                      if(!(h595_val & relay_array[lock_channel - 1]))
 208   4                      {
 209   5                          h595_val |= relay_array[lock_channel - 1];
 210   5                      }
 211   4                     
 212   4                  }
 213   3                  else
 214   3                  {
 215   4                      if(h595_val & relay_array[lock_channel - 1])
 216   4                      {
 217   5                          h595_val &= ~relay_array[lock_channel - 1];
 218   5                      }
 219   4                  }
 220   3              }
 221   2      #if 1
 222   2              if(dev_def.lock_cnt >= 50 && dev_def.lock_update)
 223   2              {
 224   3                  dev_def.lock_cnt = 0;
 225   3                  dev_def.lock_update = false;
 226   3                  h595_val |= 0x0f;
 227   3              }
 228   2              if(h595_val != last_val)
 229   2              {
 230   3                  SendTo595(h595_val);
 231   3              }
 232   2      #endif
 233   2          }
 234   1      }
 235          /*
 236          static void dealJogging(void)
 237          {
 238              uint8_t last_val = 0;
 239              jogging_cnt++;
 240              last_val = h595_val;
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 5   

 241              if(!dev_def.lock)
 242              {
 243                  dealJogging();
 244              }
 245              if(last_val != h595_val)
 246              {
 247                  SendTo595(h595_val);
 248              }
 249          }
 250          */
 251          void dealLogic(void)
 252          {
 253   1          if(key_scan_flag)
 254   1          {
 255   2              key_scan_flag = false;
 256   2              keyScan();
 257   2          }
 258   1          
 259   1          if(deal_jogging)
 260   1          {
 261   2              dealJogging();
 262   2              deal_jogging = false;
 263   2          }
 264   1          if(lock_flag)
 265   1          {
 266   2              lock_flag = false;
 267   2              dealLock();
 268   2          }
 269   1          if(update_status_flag)
 270   1          {
 271   2              updateDeviceStatus();
 272   2              update_status_flag = false;
 273   2          }
 274   1      }
 275          void logicInit(void)
 276          {
 277   1          h595Init();
 278   1          SendTo595(0x0f);
 279   1          ledInit();   
 280   1              keyInit();
 281   1          relayInit();
 282   1          timer0Init();
 283   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 284   1          dev_def.dev_channel[1].channel_mode = DEV_JOGGING;
 285   1          dev_def.dev_channel[2].channel_mode = DEV_JOGGING;
 286   1          dev_def.dev_channel[3].channel_mode = DEV_JOGGING;
 287   1          dev_def.lock = true;
 288   1          MODE_LED = 0;
 289   1      }
 290          void SendTo595(uint8_t val)
 291          {
 292   1              char i=0;
 293   1              uint8_t temp = val;
 294   1              EA = 0;
 295   1              for(i = 0; i < 8; i++)
 296   1              {
 297   2                      SER = temp>>7;
 298   2                      temp= temp<<1;
 299   2                      SCK = 0;
 300   2                      _nop_();
 301   2                      SCK = 1;
 302   2              }
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 10:57:12 PAGE 6   

 303   1              RCK = 0;
 304   1              _nop_();
 305   1              RCK = 1;
 306   1              SER = 0;
 307   1              EA = 1;
 308   1      }
 309          
 310          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1035    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
