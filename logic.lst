C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT
                    -(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          #include "flash.h"
   9          #include "remote.h"
  10          
  11          sbit RCK = P1^7;
  12          sbit SCK = P1^6;
  13          sbit SER = P3^0;
  14          
  15          bool key_scan_flag = false;
  16          bool update_local_flag = false;
  17          bool syn_app_flag = false;
  18          bool save_mode_flag = false;
  19          bool deal_remote_flag = false;
  20          bool remote_led_study = false;
  21          uint8_t remote_led_blink = 0;
  22          uint8_t update_time = 5;
  23          
  24          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  25          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  26          
  27          DevDef xdata dev_def = {0};
  28          static void h595Init(void)
  29          {
  30   1          //初始化P16 P17 P30为推挽输出
  31   1          P1M1 &= 0x3f;
  32   1              P1M2 |= 0Xc0;
  33   1              P3M1 &= 0xfe;
  34   1          P3M2 |= 0x01;
  35   1          SER = 1;
  36   1      }
  37          static void relayInit(void)
  38          {
  39   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  40   1              P0M2 &= 0Xf0;  
  41   1      }
  42          static void syncApp(void)
  43          {
  44   1          uint8_t last_key = h595_val;
  45   1          uint8_t relays[4] = {0};
  46   1          uint8_t i = 0;
  47   1          relays[0] = RELAY1;
  48   1          relays[1] = RELAY2;
  49   1          relays[2] = RELAY3;
  50   1          relays[3] = RELAY4;
  51   1          if(dev_def.lock)
  52   1          {
  53   2              static uint8_t lock_channel = 0;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 2   

  54   2              static uint8_t last_lock_channel = 0;
  55   2              static uint8_t last_relay_val[4] = {0};
  56   2              if(dev_def.dev_channel[0].update_flag 
  57   2                  || dev_def.dev_channel[1].update_flag 
  58   2                  || dev_def.dev_channel[2].update_flag
  59   2                  || dev_def.dev_channel[3].update_flag)
  60   2              {
  61   3                  return;
  62   3              }
  63   2              for(i = 0; i < 4;i++)
  64   2              {
  65   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  66   3                  {
  67   4                      lock_channel = i + 1;
  68   4                  }
  69   3                  last_relay_val[i] = relays[i];
  70   3              }
  71   2              if(last_lock_channel != lock_channel)
  72   2              {
  73   3                  last_lock_channel = lock_channel;
  74   3                  for(i = 0; i < 4; i++)
  75   3                  {
  76   4                      if(lock_channel == (i + 1))
  77   4                      {
  78   5                          h595_val &= 0x0f;
  79   5                          h595_val |= relay_array[i];
  80   5                      }
  81   4                  }
  82   3                  dev_def.dev_channel[0].update_flag = true;
  83   3                  dev_def.dev_channel[1].update_flag = true;
  84   3                  dev_def.dev_channel[2].update_flag = true;
  85   3                  dev_def.dev_channel[3].update_flag = true;
  86   3                  dev_def.update_local_cnt = 0;
  87   3                  dev_def.setting = false;
  88   3                  update_time = 5;
  89   3              }
  90   2              else
  91   2              {
  92   3                  if(relays[lock_channel - 1])
  93   3                  {
  94   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  95   4                      {
  96   5                          h595_val |= relay_array[lock_channel - 1];
  97   5                          dev_def.dev_channel[0].update_flag = true;
  98   5                          dev_def.dev_channel[1].update_flag = true;
  99   5                          dev_def.dev_channel[2].update_flag = true;
 100   5                          dev_def.dev_channel[3].update_flag = true;
 101   5                          dev_def.update_local_cnt = 0;
 102   5                          dev_def.setting = false;
 103   5                          update_time = 5;
 104   5                      }
 105   4                     
 106   4                  }
 107   3                  else
 108   3                  {
 109   4                      if(h595_val & relay_array[lock_channel - 1])
 110   4                      {
 111   5                          h595_val &= ~relay_array[lock_channel - 1];
 112   5                          dev_def.dev_channel[0].update_flag = true;
 113   5                          dev_def.dev_channel[1].update_flag = true;
 114   5                          dev_def.dev_channel[2].update_flag = true;
 115   5                          dev_def.dev_channel[3].update_flag = true;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 3   

 116   5                          dev_def.update_local_cnt = 0;
 117   5                          dev_def.setting = false;
 118   5                          update_time = 5;
 119   5                      }
 120   4                  }
 121   3              }
 122   2          }
 123   1          else
 124   1          {
 125   2              for(i =  0; i < 4; i++)
 126   2              {
 127   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 128   3                  {
 129   4                      dev_def.dev_channel[i].timer_cnt++;
 130   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 131   4                      {
 132   5                          if(dev_def.dev_channel[i].get_status == false)
 133   5                          {
 134   6                              dev_def.dev_channel[i].timer_cnt = 0;
 135   6                              dev_def.dev_channel[i].get_status = true;
 136   6                          }
 137   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 138   5                          {
 139   6                              dev_def.dev_channel[i].timer_cnt = 0;
 140   6                              dev_def.dev_channel[i].get_status = false;
 141   6                              h595_val &= (~relay_array[i]);//关掉relay1
 142   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 143   6                              dev_def.update_local_cnt = 0;
 144   6                              dev_def.setting = false;
 145   6                              update_time = 5;
 146   6                          }
 147   5                      }
 148   4                  }
 149   3                  if(!dev_def.dev_channel[i].update_flag)
 150   3                  {
 151   4                      if(relays[i])
 152   4                      {
 153   5                          h595_val |= relay_array[i];
 154   5                      }
 155   4                      else
 156   4                      {
 157   5                          h595_val &= (~relay_array[i]);
 158   5                      }
 159   4                  }
 160   3              }
 161   2          }
 162   1          if(h595_val != last_key)
 163   1          {
 164   2              SendTo595(h595_val);
 165   2          }
 166   1      }
 167          static void updateLocal(void)
 168          {
 169   1          static bool high_flag[4] = {false};
 170   1          uint8_t i = 0;
 171   1          uint8_t last_key = h595_val;
 172   1          uint8_t relays[4] = {0};
 173   1          dev_def.update_local_cnt++;
 174   1          if(dev_def.update_local_cnt == update_time)
 175   1          {
 176   2              relays[0] = (uint8_t)RELAY1;
 177   2              relays[1] = (uint8_t)RELAY2;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 4   

 178   2              relays[2] = (uint8_t)RELAY3;
 179   2              relays[3] = (uint8_t)RELAY4;
 180   2              for(i = 0; i < 4; i++)
 181   2              {
 182   3                  if(dev_def.dev_channel[i].update_flag)
 183   3                  {
 184   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 185   4                      {
 186   5                          high_flag[i] = true;
 187   5                          h595_val &= ~key_array[i];
 188   5                      }
 189   4                      else
 190   4                      {
 191   5                          dev_def.dev_channel[i].update_flag = false;
 192   5                      }
 193   4                  }
 194   3              }
 195   2              if(h595_val != last_key)
 196   2              {
 197   3                  SendTo595(h595_val);
 198   3              }
 199   2          }
 200   1          else if(dev_def.update_local_cnt >= update_time + 1)
 201   1          {
 202   2              dev_def.update_local_cnt = 0;
 203   2              for(i = 0; i < 4; i++)
 204   2              {
 205   3                  if(high_flag[i] == true)
 206   3                  {
 207   4                      h595_val |= key_array[i];
 208   4                      high_flag[i] = false;
 209   4                  }
 210   3              }
 211   2              if(h595_val != last_key)
 212   2              {
 213   3                  SendTo595(h595_val);
 214   3              }
 215   2          }
 216   1      
 217   1          
 218   1      }
 219          void dealLogic(void)
 220          {
 221   1          if(key_scan_flag)
 222   1          {
 223   2              key_scan_flag = false;
 224   2              keyScan();
 225   2          }
 226   1          if(syn_app_flag)
 227   1          {
 228   2              syn_app_flag = false;
 229   2              syncApp();
 230   2          }
 231   1          if(update_local_flag)
 232   1          {
 233   2              update_local_flag = false;
 234   2              updateLocal();//要在同步APP之后
 235   2          }
 236   1      }
 237          void saveModeToFlash(void)
 238          {
 239   1          if(save_mode_flag)
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 5   

 240   1          {
 241   2                      flash_data[0] = dev_def.lock;
 242   2                      flash_data[1] = (uint8_t)dev_def.dev_channel[0].channel_mode;
 243   2                      flash_data[2] = (uint8_t)dev_def.dev_channel[1].channel_mode;
 244   2                      flash_data[3] = (uint8_t)dev_def.dev_channel[2].channel_mode;
 245   2                      flash_data[4] = (uint8_t)dev_def.dev_channel[3].channel_mode;
 246   2                      flashWrite();
 247   2                      save_mode_flag = false;
 248   2          }
 249   1      }
 250          static void dealRemoteModeLed(void)
 251          {
 252   1          static uint8_t remote_led_cnt = 0;
 253   1          remote_led_cnt++;
 254   1          if(dev_def.remote)
 255   1              {
 256   2              if(remote_led_cnt >= 100)
 257   2              {
 258   3                  remote_led_cnt = 0;
 259   3                  MODE_LED = !MODE_LED;
 260   3              }
 261   2              }
 262   1              else
 263   1              {
 264   2              if(dev_def.lock)
 265   2              {
 266   3                  MODE_LED = 1;
 267   3              }
 268   2              else
 269   2              {
 270   3                  MODE_LED = 0;
 271   3              }
 272   2              }
 273   1      }
 274          void dealRemoteStudyLed(void)
 275          {
 276   1          static uint8_t cnt = 0;
 277   1          cnt++;
 278   1          if(cnt >= 100 && remote_led_study)
 279   1          {
 280   2              cnt = 0;
 281   2              if(RF_LED)
 282   2              {
 283   3                  RF_LED = 0;
 284   3                  remote_led_blink++;
 285   3              }
 286   2              else
 287   2              {
 288   3                  RF_LED = 1;
 289   3              }
 290   2          }
 291   1          if((remote_led_blink >= 4) && remote_led_study)
 292   1          {
 293   2              RF_LED = 0;
 294   2              remote_led_blink = 0;
 295   2              remote_led_study = false;
 296   2          }
 297   1      }
 298          void dealRemoteNormalLed(void)
 299          {
 300   1          static uint8_t cnt = 0;
 301   1          cnt++;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 6   

 302   1          if(!dev_def.remote 
 303   1          && (ir_data.ir_data == dev_def.dev_channel[1].remote_val
 304   1          || ir_data.ir_data == dev_def.dev_channel[0].remote_val
 305   1          || ir_data.ir_data == dev_def.dev_channel[2].remote_val
 306   1          || ir_data.ir_data == dev_def.dev_channel[3].remote_val)
 307   1          )
 308   1          {
 309   2              if(ir_data.cnt > 0 && cnt >= 15)
 310   2              {
 311   3                  cnt = 0;
 312   3                  RF_LED = !RF_LED;
 313   3              }
 314   2              if(ir_data.timer_cnt >= 100)
 315   2              {
 316   3                  RF_LED = 0;
 317   3              }
 318   2          }
 319   1      }
 320          void dealRemoteLed(void)
 321          {
 322   1          dealRemoteModeLed();
 323   1              dealRemoteStudyLed();
 324   1              dealRemoteNormalLed();
 325   1      }
 326          void dealRemoteStudy(void)
 327          {
 328   1          if(dev_def.remote_channel != 0 && dev_def.remote)
 329   1          {
 330   2              if(ir_data.cnt == 10)
 331   2              {
 332   3                  remote_led_study = true;
 333   3                  remote_led_blink = 0;
 334   3                  RF_LED = 0;
 335   3              }
 336   2              if(ir_data.cnt >= 10 && ir_data.timer_cnt >= 150)
 337   2              {
 338   3                  //ir_data.cnt = 0;
 339   3                  dev_def.dev_channel[dev_def.remote_channel - 1].remote_val = ir_data.ir_data;
 340   3                  clearIrData();
 341   3                  dev_def.remote_channel = 0;
 342   3              }
 343   2          }
 344   1      }
 345          void dealRemoteNormal(void)
 346          {
 347   1          static uint16_t cnt = 0;
 348   1          uint8_t i = 0;
 349   1              uint8_t relays[4] = {0};
 350   1          cnt++;
 351   1          if(!dev_def.remote)
 352   1          {
 353   2              relays[0] = RELAY1;
 354   2              relays[1] = RELAY2;
 355   2              relays[2] = RELAY3;
 356   2              relays[3] = RELAY4;
 357   2              if(ir_data.cnt == 1)
 358   2              {
 359   3                  for(i = 0; i < 4; i++)
 360   3                  {
 361   4                      if(ir_data.ir_data == dev_def.dev_channel[i].remote_val)
 362   4                      {
 363   5                          h595_val |= 0x0f;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 7   

 364   5                          h595_val &= (~key_array[i]);
 365   5                          dev_def.remote_channel = i;
 366   5                          SendTo595(h595_val);   
 367   5                          cnt = 0;
 368   5                      }
 369   4                  }
 370   3              }
 371   2              else if(ir_data.timer_cnt >= 150 && ir_data.cnt >= 1
 372   2              && ir_data.ir_data == dev_def.dev_channel[dev_def.remote_channel].remote_val)
 373   2              {
 374   3                  h595_val |= 0x0f;
 375   3                  if(cnt <= 2500)
 376   3                  {
 377   4                      if(relays[dev_def.remote_channel])
 378   4                      {
 379   5                          h595_val &= (~relay_array[dev_def.remote_channel]);    
 380   5                      }
 381   4                      else
 382   4                      {
 383   5                          if(dev_def.lock)
 384   5                          {
 385   6                              h595_val &= 0x0f;
 386   6                          }
 387   5                          h595_val |= relay_array[dev_def.remote_channel] ;
 388   5                      }
 389   4                      dev_def.remote_channel = 0;
 390   4                      dev_def.dev_channel[0].update_flag = true;
 391   4                      dev_def.dev_channel[1].update_flag = true;
 392   4                      dev_def.dev_channel[2].update_flag = true;
 393   4                      dev_def.dev_channel[3].update_flag = true;
 394   4                      dev_def.update_local_cnt = 0;
 395   4                      update_time = 10;
 396   4                  }
 397   3                  SendTo595(h595_val);
 398   3                  clearIrData();
 399   3              }
 400   2          }
 401   1      }
 402          void dealRemote(void)
 403          {
 404   1              if(deal_remote_flag)
 405   1              {
 406   2                      deal_remote_flag = false;
 407   2                      analyzeRfData();
 408   2                      dealRemoteLed();
 409   2                      dealRemoteStudy();
 410   2                      dealRemoteNormal();
 411   2              }
 412   1      }
 413          static void modeInit(void)
 414          {
 415   1              flashRead();
 416   1              dev_def.lock = flash_data[0];
 417   1              dev_def.dev_channel[0].channel_mode = flash_data[1];
 418   1              dev_def.dev_channel[1].channel_mode = flash_data[2];
 419   1              dev_def.dev_channel[2].channel_mode = flash_data[3];
 420   1              dev_def.dev_channel[3].channel_mode = flash_data[4];
 421   1          if(dev_def.lock == 0xff 
 422   1              || dev_def.dev_channel[0].channel_mode == 0xff
 423   1              || dev_def.dev_channel[1].channel_mode == 0xff
 424   1              || dev_def.dev_channel[2].channel_mode == 0xff
 425   1              || dev_def.dev_channel[3].channel_mode == 0xff)
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 8   

 426   1          {
 427   2              dev_def.lock = false;
 428   2              dev_def.dev_channel[0].channel_mode = DEV_SELFLOCK;
 429   2              dev_def.dev_channel[1].channel_mode = DEV_SELFLOCK;
 430   2              dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 431   2              dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 432   2          }
 433   1          if(dev_def.lock)
 434   1          {
 435   2              MODE_LED = 1;
 436   2          }
 437   1          else
 438   1          {
 439   2              MODE_LED = 0;
 440   2          }
 441   1      }
 442          void logicInit(void)
 443          {
 444   1          modeInit();
 445   1          h595Init();
 446   1          SendTo595(0x0f);
 447   1          ledInit();   
 448   1              keyInit();
 449   1          relayInit();
 450   1      #if 1
 451   1              captureInit();
 452   1              timer1Init();
 453   1      #endif
 454   1          timer0Init();
 455   1      }
 456          void SendTo595(uint8_t val)
 457          {
 458   1              char i=0;
 459   1              uint8_t temp = val;
 460   1              EA = 0;
 461   1              for(i = 0; i < 8; i++)
 462   1              {
 463   2                      SER = temp>>7;
 464   2                      temp= temp<<1;
 465   2                      SCK = 0;
 466   2                      _nop_();
 467   2                      SCK = 1;
 468   2              }
 469   1              RCK = 0;
 470   1              _nop_();
 471   1              RCK = 1;
 472   1              SER = 0;
 473   1              EA = 1;
 474   1      }
 475          
 476          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1752    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     41    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 20:56:10 PAGE 9   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
