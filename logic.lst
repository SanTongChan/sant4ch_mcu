C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 12:53:51 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          bool key_scan_flag = false;
  13          bool update_status_flag = false;
  14          bool led_blink_flag = false;
  15          bool deal_relay = false;
  16          DevDef dev_def = {0};
  17          uint16_t jogging_cnt = 0;
  18          static void h595Init(void)
  19          {
  20   1          //初始化P16 P17 P30为推挽输出
  21   1          P1M1 &= 0x3f;
  22   1              P1M2 |= 0Xc0;
  23   1              P3M1 &= 0xfe;
  24   1          P3M2 |= 0x01;
  25   1          SER = 1;
  26   1      }
  27          static void relayInit(void)
  28          {
  29   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  30   1              P0M2 &= 0Xf0;  
  31   1      }
  32          static void updateDeviceStatus(void)
  33          {
  34   1      #if 0
                  uint8_t temp = 0;
                  temp = (((uint8_t)RELAY1 << 7) | ((uint8_t)RELAY2 << 6) | ((uint8_t)RELAY3 << 5) | ((uint8_t)RELAY4 <<
             - 4));
                  if((temp & 0xf0) != (h595_val & 0xf0))
                  {
                      h595_val = ((h595_val & 0x0f) | (temp & 0xf0));
                      SendTo595(h595_val);
                  }
              #endif
  43   1          uint8_t last_val = 0;
  44   1          last_val = h595_val;
  45   1          if((((uint8_t)RELAY1 << 7) != (h595_val & RELAY1_595)) && (!dev_def.dev_channel[0].update_flag))
  46   1          {
  47   2              h595_val &= (~RELAY1_595);
  48   2              h595_val |= ((uint8_t)RELAY1 << 7);
  49   2          }
  50   1          if((((uint8_t)RELAY2 << 6) != (h595_val & RELAY2_595)) && (!dev_def.dev_channel[1].update_flag))
  51   1          {
  52   2              h595_val &= (~RELAY2_595);
  53   2              h595_val |= ((uint8_t)RELAY2 << 6);
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 12:53:51 PAGE 2   

  54   2          }
  55   1          if((((uint8_t)RELAY3 << 5) != (h595_val & RELAY3_595)) && (!dev_def.dev_channel[2].update_flag))
  56   1          {
  57   2              h595_val &= (~RELAY3_595);
  58   2              h595_val |= ((uint8_t)RELAY3 << 5);
  59   2          }
  60   1          if((((uint8_t)RELAY4 << 4) != (h595_val & RELAY4_595)) && (!dev_def.dev_channel[3].update_flag))
  61   1          {
  62   2              h595_val &= (~RELAY4_595);
  63   2              h595_val |= ((uint8_t)RELAY4 << 4);
  64   2          }
  65   1          if(last_val != h595_val)
  66   1          {
  67   2              SendTo595(h595_val);
  68   2          }
  69   1      }
  70          static void dealRealy(void)
  71          {
  72   1          //static bool lock = false;
  73   1          jogging_cnt++;
  74   1          if(!dev_def.lock)
  75   1          {
  76   2              if(dev_def.dev_channel[0].channel_mode == DEV_JOGGING)
  77   2              {
  78   3                  dev_def.dev_channel[0].timer_cnt++;
  79   3                  if((h595_val & RELAY1_595))//如果relay1是按下的
  80   3                  {
  81   4                      if(dev_def.dev_channel[0].get_status == false)
  82   4                      {
  83   5                          dev_def.dev_channel[0].timer_cnt = 0;
  84   5                          dev_def.dev_channel[0].get_status = true;
  85   5                      }
  86   4                      if(dev_def.dev_channel[0].timer_cnt >= 100)
  87   4                      {
  88   5                          dev_def.dev_channel[0].timer_cnt = 0;
  89   5                          dev_def.dev_channel[0].get_status = false;
  90   5                          h595_val &= (~RELAY1_595);//关掉relay1
  91   5                          dev_def.dev_channel[0].update_flag = true;//允许更新标志位
  92   5                          jogging_cnt = 0;
  93   5                      }
  94   4                  }
  95   3                  else
  96   3                  {
  97   4                      dev_def.dev_channel[0].timer_cnt = 0;
  98   4                      if(RELAY1 == 0 && dev_def.dev_channel[0].update_flag == true)
  99   4                      {
 100   5                          h595_val |= KEY1_595;
 101   5                          dev_def.dev_channel[0].update_flag = false;
 102   5                      }
 103   4                  }
 104   3                  if(jogging_cnt == 50)
 105   3                  {
 106   4                      if(dev_def.dev_channel[0].update_flag == true)
 107   4                      {
 108   5                          h595_val &= ~KEY1_595;
 109   5                      }
 110   4                  }
 111   3                  else if(jogging_cnt > 60 && jogging_cnt <= 70)
 112   3                  {
 113   4                      if(dev_def.dev_channel[0].update_flag == true)
 114   4                      {
 115   5                          if((h595_val & KEY1_595) == 0)
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 12:53:51 PAGE 3   

 116   5                          {
 117   6                               h595_val |= KEY1_595;
 118   6                          }
 119   5                      }
 120   4                  }
 121   3                  else if(jogging_cnt > 70)
 122   3                  {
 123   4                      if(((uint8_t)RELAY1 << 7) == (h595_val & RELAY1_595))
 124   4                      {
 125   5                          jogging_cnt = 0;
 126   5                          dev_def.dev_channel[0].update_flag = false;
 127   5                      }
 128   4                  }
 129   3              }
 130   2              /*
 131   2              else
 132   2              {
 133   2                  if((h595_val & KEY1_595) || dev_def.dev_channel[0].update_flag)
 134   2                  {
 135   2                      h595_val |= KEY1_595;
 136   2                      dev_def.dev_channel[0].update_flag = false;
 137   2                  }
 138   2              }
 139   2              */
 140   2              SendTo595(h595_val);
 141   2          }
 142   1          else
 143   1          {
 144   2      
 145   2          }
 146   1      }
 147          void dealLogic(void)
 148          {
 149   1          if(key_scan_flag)
 150   1          {
 151   2              key_scan_flag = false;
 152   2              keyScan();
 153   2          }
 154   1          
 155   1          if(deal_relay)
 156   1          {
 157   2              dealRealy();
 158   2              deal_relay = false;
 159   2          }
 160   1          if(update_status_flag)
 161   1          {
 162   2              updateDeviceStatus();
 163   2              update_status_flag = false;
 164   2          }
 165   1      }
 166          void logicInit(void)
 167          {
 168   1          h595Init();
 169   1          SendTo595(0x0f);
 170   1          ledInit();   
 171   1              keyInit();
 172   1          relayInit();
 173   1          timer0Init();
 174   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 175   1          MODE_LED = 0;
 176   1      }
 177          void SendTo595(uint8_t val)
C51 COMPILER V9.01   LOGIC                                                                 07/02/2017 12:53:51 PAGE 4   

 178          {
 179   1              char i=0;
 180   1              uint8_t temp = val;
 181   1              EA = 0;
 182   1              for(i = 0; i < 8; i++)
 183   1              {
 184   2                      SER = temp>>7;
 185   2                      temp= temp<<1;
 186   2                      SCK = 0;
 187   2                      _nop_();
 188   2                      SCK = 1;
 189   2              }
 190   1              RCK = 0;
 191   1              _nop_();
 192   1              RCK = 1;
 193   1              SER = 0;
 194   1              EA = 1;
 195   1      }
 196          
 197          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    476    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
