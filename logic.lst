C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT
                    -(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          #include "flash.h"
   9          #include "remote.h"
  10          
  11          sbit RCK = P1^7;
  12          sbit SCK = P1^6;
  13          sbit SER = P3^0;
  14          
  15          bool led_blink_flag = false;
  16          bool key_scan_flag = false;
  17          bool update_local_flag = false;
  18          bool deal_jogging = false;
  19          bool deal_lock = false;
  20          bool syn_app_flag = false;
  21          bool save_mode_flag = false;
  22          bool deal_remote_flag = false;
  23          uint8_t update_time = 5;
  24          
  25          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  26          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  27          
  28          DevDef xdata dev_def = {0};
  29          static void h595Init(void)
  30          {
  31   1          //初始化P16 P17 P30为推挽输出
  32   1          P1M1 &= 0x3f;
  33   1              P1M2 |= 0Xc0;
  34   1              P3M1 &= 0xfe;
  35   1          P3M2 |= 0x01;
  36   1          SER = 1;
  37   1      }
  38          static void relayInit(void)
  39          {
  40   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  41   1              P0M2 &= 0Xf0;  
  42   1      }
  43          static void syncApp(void)
  44          {
  45   1          uint8_t last_key = h595_val;
  46   1          uint8_t relays[4] = {0};
  47   1          uint8_t i = 0;
  48   1          relays[0] = RELAY1;
  49   1          relays[1] = RELAY2;
  50   1          relays[2] = RELAY3;
  51   1          relays[3] = RELAY4;
  52   1          if(dev_def.lock)
  53   1          {
C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 2   

  54   2              static uint8_t lock_channel = 0;
  55   2              static uint8_t last_lock_channel = 0;
  56   2              static uint8_t last_relay_val[4] = {0};
  57   2              if(dev_def.dev_channel[0].update_flag 
  58   2                  || dev_def.dev_channel[1].update_flag 
  59   2                  || dev_def.dev_channel[2].update_flag
  60   2                  || dev_def.dev_channel[3].update_flag)
  61   2              {
  62   3                  return;
  63   3              }
  64   2              for(i = 0; i < 4;i++)
  65   2              {
  66   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  67   3                  {
  68   4                      lock_channel = i + 1;
  69   4                  }
  70   3                  last_relay_val[i] = relays[i];
  71   3              }
  72   2              if(last_lock_channel != lock_channel)
  73   2              {
  74   3                  last_lock_channel = lock_channel;
  75   3                  for(i = 0; i < 4; i++)
  76   3                  {
  77   4                      if(lock_channel == (i + 1))
  78   4                      {
  79   5                          h595_val &= 0x0f;
  80   5                          h595_val |= relay_array[i];
  81   5                      }
  82   4                  }
  83   3                  dev_def.dev_channel[0].update_flag = true;
  84   3                  dev_def.dev_channel[1].update_flag = true;
  85   3                  dev_def.dev_channel[2].update_flag = true;
  86   3                  dev_def.dev_channel[3].update_flag = true;
  87   3                  dev_def.update_local_cnt = 0;
  88   3                  dev_def.setting = false;
  89   3                  update_time = 5;
  90   3              }
  91   2              else
  92   2              {
  93   3                  if(relays[lock_channel - 1])
  94   3                  {
  95   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  96   4                      {
  97   5                          h595_val |= relay_array[lock_channel - 1];
  98   5                          dev_def.dev_channel[0].update_flag = true;
  99   5                          dev_def.dev_channel[1].update_flag = true;
 100   5                          dev_def.dev_channel[2].update_flag = true;
 101   5                          dev_def.dev_channel[3].update_flag = true;
 102   5                          dev_def.update_local_cnt = 0;
 103   5                          dev_def.setting = false;
 104   5                          update_time = 5;
 105   5                      }
 106   4                     
 107   4                  }
 108   3                  else
 109   3                  {
 110   4                      if(h595_val & relay_array[lock_channel - 1])
 111   4                      {
 112   5                          h595_val &= ~relay_array[lock_channel - 1];
 113   5                          dev_def.dev_channel[0].update_flag = true;
 114   5                          dev_def.dev_channel[1].update_flag = true;
 115   5                          dev_def.dev_channel[2].update_flag = true;
C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 3   

 116   5                          dev_def.dev_channel[3].update_flag = true;
 117   5                          dev_def.update_local_cnt = 0;
 118   5                          dev_def.setting = false;
 119   5                          update_time = 5;
 120   5                      }
 121   4                  }
 122   3              }
 123   2          }
 124   1          else
 125   1          {
 126   2              for(i =  0; i < 4; i++)
 127   2              {
 128   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 129   3                  {
 130   4                      dev_def.dev_channel[i].timer_cnt++;
 131   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 132   4                      {
 133   5                          if(dev_def.dev_channel[i].get_status == false)
 134   5                          {
 135   6                              dev_def.dev_channel[i].timer_cnt = 0;
 136   6                              dev_def.dev_channel[i].get_status = true;
 137   6                          }
 138   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 139   5                          {
 140   6                              dev_def.dev_channel[i].timer_cnt = 0;
 141   6                              dev_def.dev_channel[i].get_status = false;
 142   6                              h595_val &= (~relay_array[i]);//关掉relay1
 143   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 144   6                              dev_def.update_local_cnt = 0;
 145   6                              dev_def.setting = false;
 146   6                              update_time = 5;
 147   6                          }
 148   5                      }
 149   4                  }
 150   3                  if(!dev_def.dev_channel[i].update_flag)
 151   3                  {
 152   4                      if(relays[i])
 153   4                      {
 154   5                          h595_val |= relay_array[i];
 155   5                      }
 156   4                      else
 157   4                      {
 158   5                          h595_val &= (~relay_array[i]);
 159   5                      }
 160   4                  }
 161   3              }
 162   2          }
 163   1          if(h595_val != last_key)
 164   1          {
 165   2              SendTo595(h595_val);
 166   2          }
 167   1      }
 168          static void updateLocal(void)
 169          {
 170   1          static bool high_flag[4] = {false};
 171   1          uint8_t i = 0;
 172   1          uint8_t last_key = h595_val;
 173   1          uint8_t relays[4] = {0};
 174   1          dev_def.update_local_cnt++;
 175   1          if(dev_def.update_local_cnt == update_time)
 176   1          {
 177   2              relays[0] = (uint8_t)RELAY1;
C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 4   

 178   2              relays[1] = (uint8_t)RELAY2;
 179   2              relays[2] = (uint8_t)RELAY3;
 180   2              relays[3] = (uint8_t)RELAY4;
 181   2              for(i = 0; i < 4; i++)
 182   2              {
 183   3                  if(dev_def.dev_channel[i].update_flag)
 184   3                  {
 185   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 186   4                      {
 187   5                          high_flag[i] = true;
 188   5                          h595_val &= ~key_array[i];
 189   5                      }
 190   4                      else
 191   4                      {
 192   5                          dev_def.dev_channel[i].update_flag = false;
 193   5                      }
 194   4                  }
 195   3              }
 196   2              if(h595_val != last_key)
 197   2              {
 198   3                  SendTo595(h595_val);
 199   3              }
 200   2          }
 201   1          else if(dev_def.update_local_cnt >= update_time + 1)
 202   1          {
 203   2              dev_def.update_local_cnt = 0;
 204   2              for(i = 0; i < 4; i++)
 205   2              {
 206   3                  if(high_flag[i] == true)
 207   3                  {
 208   4                      h595_val |= key_array[i];
 209   4                      high_flag[i] = false;
 210   4                  }
 211   3              }
 212   2              if(h595_val != last_key)
 213   2              {
 214   3                  SendTo595(h595_val);
 215   3              }
 216   2          }
 217   1      
 218   1          
 219   1      }
 220          void dealLogic(void)
 221          {
 222   1          if(key_scan_flag)
 223   1          {
 224   2              key_scan_flag = false;
 225   2              keyScan();
 226   2          }
 227   1          if(syn_app_flag)
 228   1          {
 229   2              syn_app_flag = false;
 230   2              syncApp();
 231   2          }
 232   1          if(update_local_flag)
 233   1          {
 234   2              update_local_flag = false;
 235   2              updateLocal();//要在同步APP之后
 236   2          }
 237   1      }
 238          void saveModeToFlash(void)
 239          {
C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 5   

 240   1          if(save_mode_flag)
 241   1          {
 242   2              save_mode_flag = false;
 243   2              write_DATAFLASH_BYTE (0x3881,dev_def.lock);
 244   2              write_DATAFLASH_BYTE (0x3882,(uint8_t)dev_def.dev_channel[0].channel_mode);
 245   2              write_DATAFLASH_BYTE (0x3883,(uint8_t)dev_def.dev_channel[1].channel_mode);
 246   2              write_DATAFLASH_BYTE (0x3884,(uint8_t)dev_def.dev_channel[2].channel_mode);
 247   2              write_DATAFLASH_BYTE (0x3885,(uint8_t)dev_def.dev_channel[3].channel_mode);
 248   2          }
 249   1      }
 250          void dealRemote(void)
 251          {
 252   1              if(deal_remote_flag)
 253   1              {
 254   2                      deal_remote_flag = false;
 255   2                      analyzeRfData();
 256   2              }
 257   1      }
 258          static void modeInit(void)
 259          {
 260   1          dev_def.lock = read_APROM_BYTE(0x3881);
 261   1          dev_def.dev_channel[0].channel_mode = read_APROM_BYTE(0x3882);
 262   1          dev_def.dev_channel[1].channel_mode = read_APROM_BYTE(0x3883);
 263   1          dev_def.dev_channel[2].channel_mode = read_APROM_BYTE(0x3884);
 264   1          dev_def.dev_channel[3].channel_mode = read_APROM_BYTE(0x3885);
 265   1          if(dev_def.lock == 0xff 
 266   1              || dev_def.dev_channel[0].channel_mode == 0xff
 267   1              || dev_def.dev_channel[1].channel_mode == 0xff
 268   1              || dev_def.dev_channel[2].channel_mode == 0xff
 269   1              || dev_def.dev_channel[3].channel_mode == 0xff)
 270   1          {
 271   2              dev_def.lock = false;
 272   2              dev_def.dev_channel[0].channel_mode = DEV_SELFLOCK;
 273   2              dev_def.dev_channel[1].channel_mode = DEV_SELFLOCK;
 274   2              dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 275   2              dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 276   2          }
 277   1          if(dev_def.lock)
 278   1          {
 279   2              MODE_LED = 1;
 280   2          }
 281   1          else
 282   1          {
 283   2              MODE_LED = 0;
 284   2          }
 285   1      }
 286          void logicInit(void)
 287          {
 288   1          modeInit();
 289   1          h595Init();
 290   1          SendTo595(0x0f);
 291   1          ledInit();   
 292   1              keyInit();
 293   1          relayInit();
 294   1      #if 1
 295   1              captureInit();
 296   1              timer1Init();
 297   1      #endif
 298   1          timer0Init();
 299   1      }
 300          void SendTo595(uint8_t val)
 301          {
C51 COMPILER V9.01   LOGIC                                                                 07/13/2017 16:31:03 PAGE 6   

 302   1              char i=0;
 303   1              uint8_t temp = val;
 304   1              EA = 0;
 305   1              for(i = 0; i < 8; i++)
 306   1              {
 307   2                      SER = temp>>7;
 308   2                      temp= temp<<1;
 309   2                      SCK = 0;
 310   2                      _nop_();
 311   2                      SCK = 1;
 312   2              }
 313   1              RCK = 0;
 314   1              _nop_();
 315   1              RCK = 1;
 316   1              SER = 0;
 317   1              EA = 1;
 318   1      }
 319          
 320          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1083    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
