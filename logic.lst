C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 19:39:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          
  13          bool led_blink_flag = false;
  14          bool key_scan_flag = false;
  15          bool update_local_flag = false;
  16          bool deal_jogging = false;
  17          bool deal_lock = false;
  18          bool syn_app_flag = false;
  19          uint8_t update_time = 5;
  20          
  21          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  22          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  23          
  24          DevDef xdata dev_def = {0};
  25          static void h595Init(void)
  26          {
  27   1          //初始化P16 P17 P30为推挽输出
  28   1          P1M1 &= 0x3f;
  29   1              P1M2 |= 0Xc0;
  30   1              P3M1 &= 0xfe;
  31   1          P3M2 |= 0x01;
  32   1          SER = 1;
  33   1      }
  34          static void relayInit(void)
  35          {
  36   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  37   1              P0M2 &= 0Xf0;  
  38   1      }
  39          static void syncApp(void)
  40          {
  41   1          uint8_t last_key = h595_val;
  42   1          uint8_t relays[4] = {0};
  43   1          uint8_t i = 0;
  44   1          relays[0] = RELAY1;
  45   1          relays[1] = RELAY2;
  46   1          relays[2] = RELAY3;
  47   1          relays[3] = RELAY4;
  48   1          if(dev_def.lock)
  49   1          {
  50   2              static uint8_t lock_channel = 0;
  51   2              static uint8_t last_lock_channel = 0;
  52   2              static uint8_t last_relay_val[4] = {0};
  53   2              if(dev_def.dev_channel[0].update_flag 
  54   2                  || dev_def.dev_channel[1].update_flag 
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 19:39:55 PAGE 2   

  55   2                  || dev_def.dev_channel[2].update_flag
  56   2                  || dev_def.dev_channel[3].update_flag)
  57   2              {
  58   3                  return;
  59   3              }
  60   2              for(i = 0; i < 4;i++)
  61   2              {
  62   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  63   3                  {
  64   4                      lock_channel = i + 1;
  65   4                  }
  66   3                  last_relay_val[i] = relays[i];
  67   3              }
  68   2              if(last_lock_channel != lock_channel)
  69   2              {
  70   3                  last_lock_channel = lock_channel;
  71   3                  for(i = 0; i < 4; i++)
  72   3                  {
  73   4                      if(lock_channel == (i + 1))
  74   4                      {
  75   5                          h595_val &= 0x0f;
  76   5                          h595_val |= relay_array[i];
  77   5                      }
  78   4                  }
  79   3                  dev_def.dev_channel[0].update_flag = true;
  80   3                  dev_def.dev_channel[1].update_flag = true;
  81   3                  dev_def.dev_channel[2].update_flag = true;
  82   3                  dev_def.dev_channel[3].update_flag = true;
  83   3                  dev_def.update_local_cnt = 0;
  84   3                  dev_def.setting = false;
  85   3                  update_time = 5;
  86   3              }
  87   2              else
  88   2              {
  89   3                  if(relays[lock_channel - 1])
  90   3                  {
  91   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  92   4                      {
  93   5                          h595_val |= relay_array[lock_channel - 1];
  94   5                          dev_def.dev_channel[0].update_flag = true;
  95   5                          dev_def.dev_channel[1].update_flag = true;
  96   5                          dev_def.dev_channel[2].update_flag = true;
  97   5                          dev_def.dev_channel[3].update_flag = true;
  98   5                          dev_def.update_local_cnt = 0;
  99   5                          dev_def.setting = false;
 100   5                          update_time = 5;
 101   5                      }
 102   4                     
 103   4                  }
 104   3                  else
 105   3                  {
 106   4                      if(h595_val & relay_array[lock_channel - 1])
 107   4                      {
 108   5                          h595_val &= ~relay_array[lock_channel - 1];
 109   5                          dev_def.dev_channel[0].update_flag = true;
 110   5                          dev_def.dev_channel[1].update_flag = true;
 111   5                          dev_def.dev_channel[2].update_flag = true;
 112   5                          dev_def.dev_channel[3].update_flag = true;
 113   5                          dev_def.update_local_cnt = 0;
 114   5                          dev_def.setting = false;
 115   5                          update_time = 5;
 116   5                      }
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 19:39:55 PAGE 3   

 117   4                  }
 118   3              }
 119   2          }
 120   1          else
 121   1          {
 122   2              for(i =  0; i < 4; i++)
 123   2              {
 124   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 125   3                  {
 126   4                      dev_def.dev_channel[i].timer_cnt++;
 127   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 128   4                      {
 129   5                          if(dev_def.dev_channel[i].get_status == false)
 130   5                          {
 131   6                              dev_def.dev_channel[i].timer_cnt = 0;
 132   6                              dev_def.dev_channel[i].get_status = true;
 133   6                          }
 134   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 135   5                          {
 136   6                              dev_def.dev_channel[i].timer_cnt = 0;
 137   6                              dev_def.dev_channel[i].get_status = false;
 138   6                              h595_val &= (~relay_array[i]);//关掉relay1
 139   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 140   6                              dev_def.update_local_cnt = 0;
 141   6                              dev_def.setting = false;
 142   6                              update_time = 5;
 143   6                          }
 144   5                      }
 145   4                  }
 146   3                  if(!dev_def.dev_channel[i].update_flag)
 147   3                  {
 148   4                      if(relays[i])
 149   4                      {
 150   5                          h595_val |= relay_array[i];
 151   5                      }
 152   4                      else
 153   4                      {
 154   5                          h595_val &= (~relay_array[i]);
 155   5                      }
 156   4                  }
 157   3              }
 158   2          }
 159   1          if(h595_val != last_key)
 160   1          {
 161   2              SendTo595(h595_val);
 162   2          }
 163   1      }
 164          static void updateLocal(void)
 165          {
 166   1          static bool high_flag[4] = {false};
 167   1          uint8_t i = 0;
 168   1          uint8_t last_key = h595_val;
 169   1          uint8_t relays[4] = {0};
 170   1          dev_def.update_local_cnt++;
 171   1          if(dev_def.update_local_cnt == update_time)
 172   1          {
 173   2              relays[0] = (uint8_t)RELAY1;
 174   2              relays[1] = (uint8_t)RELAY2;
 175   2              relays[2] = (uint8_t)RELAY3;
 176   2              relays[3] = (uint8_t)RELAY4;
 177   2              for(i = 0; i < 4; i++)
 178   2              {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 19:39:55 PAGE 4   

 179   3                  if(dev_def.dev_channel[i].update_flag)
 180   3                  {
 181   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 182   4                      {
 183   5                          high_flag[i] = true;
 184   5                          h595_val &= ~key_array[i];
 185   5                      }
 186   4                      else
 187   4                      {
 188   5                          dev_def.dev_channel[i].update_flag = false;
 189   5                      }
 190   4                  }
 191   3              }
 192   2              if(h595_val != last_key)
 193   2              {
 194   3                  MODE_LED = !MODE_LED;
 195   3                  SendTo595(h595_val);
 196   3              }
 197   2          }
 198   1          else if(dev_def.update_local_cnt >= update_time + 1)
 199   1          {
 200   2              dev_def.update_local_cnt = 0;
 201   2              for(i = 0; i < 4; i++)
 202   2              {
 203   3                  if(high_flag[i] == true)
 204   3                  {
 205   4                      h595_val |= key_array[i];
 206   4                      high_flag[i] = false;
 207   4                  }
 208   3              }
 209   2              if(h595_val != last_key)
 210   2              {
 211   3                  MODE_LED = !MODE_LED;
 212   3                  SendTo595(h595_val);
 213   3              }
 214   2          }
 215   1      
 216   1          
 217   1      }
 218          void dealLogic(void)
 219          {
 220   1          if(key_scan_flag)
 221   1          {
 222   2              key_scan_flag = false;
 223   2              keyScan();
 224   2          }
 225   1          if(syn_app_flag)
 226   1          {
 227   2              syn_app_flag = false;
 228   2              syncApp();
 229   2          }
 230   1          if(update_local_flag)
 231   1          {
 232   2              update_local_flag = false;
 233   2              updateLocal();//要在同步APP之后
 234   2          }
 235   1          
 236   1      }
 237          void logicInit(void)
 238          {
 239   1          h595Init();
 240   1          SendTo595(0x0f);
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 19:39:55 PAGE 5   

 241   1          ledInit();   
 242   1              keyInit();
 243   1          relayInit();
 244   1          timer0Init();
 245   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 246   1          dev_def.dev_channel[1].channel_mode = DEV_JOGGING;
 247   1          dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 248   1          dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 249   1          dev_def.lock = false;
 250   1          MODE_LED = 0;
 251   1      }
 252          void SendTo595(uint8_t val)
 253          {
 254   1              char i=0;
 255   1              uint8_t temp = val;
 256   1              EA = 0;
 257   1              for(i = 0; i < 8; i++)
 258   1              {
 259   2                      SER = temp>>7;
 260   2                      temp= temp<<1;
 261   2                      SCK = 0;
 262   2                      _nop_();
 263   2                      SCK = 1;
 264   2              }
 265   1              RCK = 0;
 266   1              _nop_();
 267   1              RCK = 1;
 268   1              SER = 0;
 269   1              EA = 1;
 270   1      }
 271          
 272          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    895    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
