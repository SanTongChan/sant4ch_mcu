C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          
  13          
  14          
  15          bool led_blink_flag = false;
  16          
  17          
  18          
  19          bool key_scan_flag = false;
  20          bool update_local_flag = false;
  21          bool deal_jogging = false;
  22          bool deal_lock = false;
  23          bool syn_app_flag = false;
  24          
  25          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  26          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  27          
  28          DevDef xdata dev_def = {0};
  29          uint16_t jogging_cnt = 0;
  30          static void h595Init(void)
  31          {
  32   1          //初始化P16 P17 P30为推挽输出
  33   1          P1M1 &= 0x3f;
  34   1              P1M2 |= 0Xc0;
  35   1              P3M1 &= 0xfe;
  36   1          P3M2 |= 0x01;
  37   1          SER = 1;
  38   1      }
  39          static void relayInit(void)
  40          {
  41   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  42   1              P0M2 &= 0Xf0;  
  43   1      }
  44          #if 0
              static void updateDeviceStatus(void)
              {
                  uint8_t last_val = 0;
                  if(!dev_def.lock)
                  {
                      last_val = h595_val;
                      if((((uint8_t)RELAY1 << 7) != (h595_val & RELAY1_595)) && (!dev_def.dev_channel[0].update_flag))
                      {
                          h595_val &= (~RELAY1_595);
                          h595_val |= ((uint8_t)RELAY1 << 7);
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 2   

                      }
                      if((((uint8_t)RELAY2 << 6) != (h595_val & RELAY2_595)) && (!dev_def.dev_channel[1].update_flag))
                      {   
                          h595_val = (~RELAY2_595);
                          h595_val |= ((uint8_t)RELAY2 << 6);
                      }
                      if((((uint8_t)RELAY3 << 5) != (h595_val & RELAY3_595)) && (!dev_def.dev_channel[2].update_flag))
                      {
                          h595_val &= (~RELAY3_595);
                          h595_val |= ((uint8_t)RELAY3 << 5);
                      }
                      if((((uint8_t)RELAY4 << 4) != (h595_val & RELAY4_595)) && (!dev_def.dev_channel[3].update_flag))
                      {
                          h595_val &= (~RELAY4_595);
                          h595_val |= ((uint8_t)RELAY4 << 4);
                      }
                      if(last_val != h595_val)
                      {
                          SendTo595(h595_val);
                      }
                  }
              }
              static void dealJogging(void)
              {
                  uint8_t relays[4] = {0};
                  uint8_t i = 0;
                  uint8_t last_val = 0;
                  if(!dev_def.lock)
                  {
                      jogging_cnt++;
                      last_val = h595_val;
                      relays[0] = (uint8_t)RELAY1;
                      relays[1] = (uint8_t)RELAY2;
                      relays[2] = (uint8_t)RELAY3;
                      relays[3] = (uint8_t)RELAY4;
                      for(i =  0; i < 4; i++)
                      {
                          if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
                          {
                              dev_def.dev_channel[i].timer_cnt++;
                              if((h595_val & relay_array[i]))//如果relay1是按下的
                              {
                                  if(dev_def.dev_channel[i].get_status == false)
                                  {
                                      dev_def.dev_channel[i].timer_cnt = 0;
                                      dev_def.dev_channel[i].get_status = true;
                                  }
                                  if(dev_def.dev_channel[i].timer_cnt >= 100)
                                  {
                                      dev_def.dev_channel[i].timer_cnt = 0;
                                      dev_def.dev_channel[i].get_status = false;
                                      h595_val &= (~relay_array[i]);//关掉relay1
                                      dev_def.dev_channel[i].update_flag = true;//允许更新标志位
                                      jogging_cnt = 0;
                                  }
                              }
                              else
                              {
                                  dev_def.dev_channel[i].timer_cnt = 0;
                                  if(relays[i] == 0 && dev_def.dev_channel[i].update_flag == true)
                                  {
                                      h595_val |= key_array[i];
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 3   

                                      dev_def.dev_channel[i].update_flag = false;
                                  }
                              }
                          }
                      }
                      if(jogging_cnt == 80)
                      {
                          for (i = 0; i < 4; i++)
                          {
                              if((dev_def.dev_channel[i].update_flag == true) 
                                  && ((h595_val & key_array[i]))
                                  && (!dev_def.dev_channel[i].lock))
                              {
                                  h595_val &= ~key_array[i];
                              }
                          }
                      }
                      else if(jogging_cnt == 100)
                      {
                          for(i = 0; i < 4; i++)
                          {
                              if((dev_def.dev_channel[i].update_flag == true)
                                  && ((h595_val & key_array[i]) == 0)
                                  && (!dev_def.dev_channel[i].lock))
                              {
                                  //MODE_LED = 1;
                                  h595_val |= key_array[i];
                                  dev_def.dev_channel[i].lock = true;
                              }
                          }
                      }
                      for(i = 0; i < 4; i++)
                      {
                          if((relays[i] << (7 - i)) == (h595_val & relay_array[i])
                              && dev_def.dev_channel[i].lock == true)
                          {
                              dev_def.dev_channel[i].lock = false;
                              dev_def.dev_channel[i].update_flag = false;
                          }
                      }    
                      if(last_val != h595_val)
                      {
                          SendTo595(h595_val);
                      }
                  }
              }
              static void dealLock(void)
              {
                  static uint8_t lock_channel = 0;
                  static uint8_t last_lock_channel = 0;
                  static uint8_t last_relay_val[4] = {0};
                  uint8_t relays[4] = {0};
                  uint8_t i = 0;
                  uint8_t last_val = h595_val;
                  if(dev_def.lock)
                  {
                      dev_def.lock_cnt++;
                      relays[0] = RELAY1;
                      relays[1] = RELAY2;
                      relays[2] = RELAY3;
                      relays[3] = RELAY4;
                      for(i = 0; i < 4;i++)
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 4   

                      {
                          if(relays[i] != last_relay_val[i] && relays[i] == 1)
                          {
                              lock_channel = i + 1;
                          }
                          last_relay_val[i] = relays[i];
                      }
                      if(last_lock_channel != lock_channel)
                      {
                          MODE_LED = !MODE_LED;
                          last_lock_channel = lock_channel;
                          for(i = 0; i < 4; i++)
                          {
                              if(relays[i] == 1 && lock_channel != (i + 1))
                              {
                                  h595_val &= ~key_array[i];
                                  h595_val &= ~relay_array[i];
                              }
                              else if(lock_channel == (i + 1))
                              {
                                  h595_val &= 0x0f;
                                  h595_val |= relay_array[i];
                              }
                          }
                          dev_def.lock_cnt = 0;
                          dev_def.lock_update = true;
                      }
                      else
                      {
                          if(relays[lock_channel - 1])
                          {
                              if(!(h595_val & relay_array[lock_channel - 1]))
                              {
                                  h595_val |= relay_array[lock_channel - 1];
                              }
                             
                          }
                          else
                          {
                              if(h595_val & relay_array[lock_channel - 1])
                              {
                                  h595_val &= ~relay_array[lock_channel - 1];
                              }
                          }
                      }
                      if(dev_def.lock_cnt >= 30 && dev_def.lock_update)
                      {
                          dev_def.lock_cnt = 0;
                          dev_def.lock_update = false;
                          h595_val |= 0x0f;
                          //h595_val &= 0x0f;
                         // h595_val |= relay_array[lock_channel - 1];
                      }
                      if(h595_val != last_val)
                      {
                          SendTo595(h595_val);
                      }
                  }
              }
              #endif
 239          static void syncApp(void)
 240          {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 5   

 241   1          uint8_t last_key = h595_val;
 242   1          uint8_t relays[4] = {0};
 243   1          uint8_t i = 0;
 244   1          if(dev_def.dev_channel[0].update_flag 
 245   1              || dev_def.dev_channel[1].update_flag 
 246   1              || dev_def.dev_channel[2].update_flag
 247   1              || dev_def.dev_channel[3].update_flag)
 248   1          {
 249   2              return;
 250   2          }
 251   1          relays[0] = RELAY1;
 252   1          relays[1] = RELAY2;
 253   1          relays[2] = RELAY3;
 254   1          relays[3] = RELAY4;
 255   1          if(dev_def.lock)
 256   1          {
 257   2              static uint8_t lock_channel = 0;
 258   2              static uint8_t last_lock_channel = 0;
 259   2              static uint8_t last_relay_val[4] = {0};
 260   2              for(i = 0; i < 4;i++)
 261   2              {
 262   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
 263   3                  {
 264   4                      lock_channel = i + 1;
 265   4                  }
 266   3                  last_relay_val[i] = relays[i];
 267   3              }
 268   2              if(last_lock_channel != lock_channel)
 269   2              {
 270   3                  last_lock_channel = lock_channel;
 271   3                  for(i = 0; i < 4; i++)
 272   3                  {
 273   4                      if(lock_channel == (i + 1))
 274   4                      {
 275   5                          h595_val &= 0x0f;
 276   5                          h595_val |= relay_array[i];
 277   5                      }
 278   4                      dev_def.dev_channel[i].update_flag = true;
 279   4                  }
 280   3              }
 281   2              else
 282   2              {
 283   3                  if(relays[lock_channel - 1])
 284   3                  {
 285   4                      if(!(h595_val & relay_array[lock_channel - 1]))
 286   4                      {
 287   5                          h595_val |= relay_array[lock_channel - 1];
 288   5                          dev_def.dev_channel[0].update_flag = true;
 289   5                          dev_def.dev_channel[1].update_flag = true;
 290   5                          dev_def.dev_channel[2].update_flag = true;
 291   5                          dev_def.dev_channel[3].update_flag = true;
 292   5                      }
 293   4                     
 294   4                  }
 295   3                  else
 296   3                  {
 297   4                      if(h595_val & relay_array[lock_channel - 1])
 298   4                      {
 299   5                          h595_val &= ~relay_array[lock_channel - 1];
 300   5                          dev_def.dev_channel[0].update_flag = true;
 301   5                          dev_def.dev_channel[1].update_flag = true;
 302   5                          dev_def.dev_channel[2].update_flag = true;
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 6   

 303   5                          dev_def.dev_channel[3].update_flag = true;
 304   5                      }
 305   4                  }
 306   3              }
 307   2          }
 308   1          else
 309   1          {
 310   2      
 311   2          }
 312   1          if(h595_val != last_key)
 313   1          {
 314   2              SendTo595(h595_val);
 315   2          }
 316   1      }
 317          static void updateLocal(void)
 318          {
 319   1          static bool high_flag[4] = {false};
 320   1          uint8_t i = 0;
 321   1          uint8_t last_key = h595_val;
 322   1          uint8_t relays[4] = {0};
 323   1          dev_def.update_local_cnt++;
 324   1          if(dev_def.update_local_cnt == 5)
 325   1          {
 326   2              //dev_def.update_local_cnt = 0;
 327   2              relays[0] = (uint8_t)RELAY1;
 328   2              relays[1] = (uint8_t)RELAY2;
 329   2              relays[2] = (uint8_t)RELAY3;
 330   2              relays[3] = (uint8_t)RELAY4;
 331   2              for(i = 0; i < 4; i++)
 332   2              {
 333   3                  if(dev_def.dev_channel[i].update_flag)
 334   3                  {
 335   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 336   4                      {
 337   5                          high_flag[i] = true;
 338   5                          h595_val &= ~key_array[i];
 339   5                      }
 340   4                      else
 341   4                      {
 342   5                          dev_def.dev_channel[i].update_flag = false;
 343   5                      }
 344   4                  }
 345   3              }
 346   2          }
 347   1          if(dev_def.update_local_cnt >= 6)
 348   1          {
 349   2              dev_def.update_local_cnt = 0;
 350   2              for(i = 0; i < 4; i++)
 351   2              {
 352   3                  if(high_flag[i] == true)
 353   3                  {
 354   4                      h595_val |= key_array[i];
 355   4                      high_flag[i] = false;
 356   4                  }
 357   3              }
 358   2          }
 359   1          if(h595_val != last_key)
 360   1          {
 361   2              SendTo595(h595_val);
 362   2          }
 363   1      }
 364          void dealLogic(void)
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 7   

 365          {
 366   1          if(key_scan_flag)
 367   1          {
 368   2              key_scan_flag = false;
 369   2              keyScan();
 370   2          }
 371   1          if(syn_app_flag)
 372   1          {
 373   2              syn_app_flag = false;
 374   2              syncApp();
 375   2          }
 376   1      #if 1
 377   1          if(update_local_flag)
 378   1          {
 379   2              update_local_flag = false;
 380   2              updateLocal();//要在同步APP之后
 381   2          }
 382   1      #endif
 383   1       #if 0
                  if(deal_jogging)
                  {
                      dealJogging();
                      deal_jogging = false;
                  }
                  if(lock_flag)
                  {
                      lock_flag = false;
                      dealLock();
                  }
                  if(update_status_flag)
                  {
                      updateDeviceStatus();
                      update_status_flag = false;
                  }
              #endif
 400   1      }
 401          void logicInit(void)
 402          {
 403   1          h595Init();
 404   1          SendTo595(0x0f);
 405   1          ledInit();   
 406   1              keyInit();
 407   1          relayInit();
 408   1          timer0Init();
 409   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 410   1          dev_def.dev_channel[1].channel_mode = DEV_JOGGING;
 411   1          dev_def.dev_channel[2].channel_mode = DEV_JOGGING;
 412   1          dev_def.dev_channel[3].channel_mode = DEV_JOGGING;
 413   1          dev_def.lock = true;
 414   1          MODE_LED = 0;
 415   1      }
 416          void SendTo595(uint8_t val)
 417          {
 418   1              char i=0;
 419   1              uint8_t temp = val;
 420   1              EA = 0;
 421   1              for(i = 0; i < 8; i++)
 422   1              {
 423   2                      SER = temp>>7;
 424   2                      temp= temp<<1;
 425   2                      SCK = 0;
 426   2                      _nop_();
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 15:30:56 PAGE 8   

 427   2                      SCK = 1;
 428   2              }
 429   1              RCK = 0;
 430   1              _nop_();
 431   1              RCK = 1;
 432   1              SER = 0;
 433   1              EA = 1;
 434   1      }
 435          
 436          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    610    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     29    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
