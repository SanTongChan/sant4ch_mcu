C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT
                    -(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          #include "flash.h"
   9          #include "remote.h"
  10          
  11          sbit RCK = P1^7;
  12          sbit SCK = P1^6;
  13          sbit SER = P3^0;
  14          
  15          bool led_blink_flag = false;
  16          bool key_scan_flag = false;
  17          bool update_local_flag = false;
  18          bool syn_app_flag = false;
  19          bool save_mode_flag = false;
  20          bool deal_remote_flag = false;
  21          uint8_t update_time = 5;
  22          
  23          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  24          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  25          
  26          DevDef xdata dev_def = {0};
  27          static void h595Init(void)
  28          {
  29   1          //初始化P16 P17 P30为推挽输出
  30   1          P1M1 &= 0x3f;
  31   1              P1M2 |= 0Xc0;
  32   1              P3M1 &= 0xfe;
  33   1          P3M2 |= 0x01;
  34   1          SER = 1;
  35   1      }
  36          static void relayInit(void)
  37          {
  38   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  39   1              P0M2 &= 0Xf0;  
  40   1      }
  41          static void syncApp(void)
  42          {
  43   1          uint8_t last_key = h595_val;
  44   1          uint8_t relays[4] = {0};
  45   1          uint8_t i = 0;
  46   1          relays[0] = RELAY1;
  47   1          relays[1] = RELAY2;
  48   1          relays[2] = RELAY3;
  49   1          relays[3] = RELAY4;
  50   1          if(dev_def.lock)
  51   1          {
  52   2              static uint8_t lock_channel = 0;
  53   2              static uint8_t last_lock_channel = 0;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 2   

  54   2              static uint8_t last_relay_val[4] = {0};
  55   2              if(dev_def.dev_channel[0].update_flag 
  56   2                  || dev_def.dev_channel[1].update_flag 
  57   2                  || dev_def.dev_channel[2].update_flag
  58   2                  || dev_def.dev_channel[3].update_flag)
  59   2              {
  60   3                  return;
  61   3              }
  62   2              for(i = 0; i < 4;i++)
  63   2              {
  64   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  65   3                  {
  66   4                      lock_channel = i + 1;
  67   4                  }
  68   3                  last_relay_val[i] = relays[i];
  69   3              }
  70   2              if(last_lock_channel != lock_channel)
  71   2              {
  72   3                  last_lock_channel = lock_channel;
  73   3                  for(i = 0; i < 4; i++)
  74   3                  {
  75   4                      if(lock_channel == (i + 1))
  76   4                      {
  77   5                          h595_val &= 0x0f;
  78   5                          h595_val |= relay_array[i];
  79   5                      }
  80   4                  }
  81   3                  dev_def.dev_channel[0].update_flag = true;
  82   3                  dev_def.dev_channel[1].update_flag = true;
  83   3                  dev_def.dev_channel[2].update_flag = true;
  84   3                  dev_def.dev_channel[3].update_flag = true;
  85   3                  dev_def.update_local_cnt = 0;
  86   3                  dev_def.setting = false;
  87   3                  update_time = 5;
  88   3              }
  89   2              else
  90   2              {
  91   3                  if(relays[lock_channel - 1])
  92   3                  {
  93   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  94   4                      {
  95   5                          h595_val |= relay_array[lock_channel - 1];
  96   5                          dev_def.dev_channel[0].update_flag = true;
  97   5                          dev_def.dev_channel[1].update_flag = true;
  98   5                          dev_def.dev_channel[2].update_flag = true;
  99   5                          dev_def.dev_channel[3].update_flag = true;
 100   5                          dev_def.update_local_cnt = 0;
 101   5                          dev_def.setting = false;
 102   5                          update_time = 5;
 103   5                      }
 104   4                     
 105   4                  }
 106   3                  else
 107   3                  {
 108   4                      if(h595_val & relay_array[lock_channel - 1])
 109   4                      {
 110   5                          h595_val &= ~relay_array[lock_channel - 1];
 111   5                          dev_def.dev_channel[0].update_flag = true;
 112   5                          dev_def.dev_channel[1].update_flag = true;
 113   5                          dev_def.dev_channel[2].update_flag = true;
 114   5                          dev_def.dev_channel[3].update_flag = true;
 115   5                          dev_def.update_local_cnt = 0;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 3   

 116   5                          dev_def.setting = false;
 117   5                          update_time = 5;
 118   5                      }
 119   4                  }
 120   3              }
 121   2          }
 122   1          else
 123   1          {
 124   2              for(i =  0; i < 4; i++)
 125   2              {
 126   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 127   3                  {
 128   4                      dev_def.dev_channel[i].timer_cnt++;
 129   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 130   4                      {
 131   5                          if(dev_def.dev_channel[i].get_status == false)
 132   5                          {
 133   6                              dev_def.dev_channel[i].timer_cnt = 0;
 134   6                              dev_def.dev_channel[i].get_status = true;
 135   6                          }
 136   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 137   5                          {
 138   6                              dev_def.dev_channel[i].timer_cnt = 0;
 139   6                              dev_def.dev_channel[i].get_status = false;
 140   6                              h595_val &= (~relay_array[i]);//关掉relay1
 141   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 142   6                              dev_def.update_local_cnt = 0;
 143   6                              dev_def.setting = false;
 144   6                              update_time = 5;
 145   6                          }
 146   5                      }
 147   4                  }
 148   3                  if(!dev_def.dev_channel[i].update_flag)
 149   3                  {
 150   4                      if(relays[i])
 151   4                      {
 152   5                          h595_val |= relay_array[i];
 153   5                      }
 154   4                      else
 155   4                      {
 156   5                          h595_val &= (~relay_array[i]);
 157   5                      }
 158   4                  }
 159   3              }
 160   2          }
 161   1          if(h595_val != last_key)
 162   1          {
 163   2              SendTo595(h595_val);
 164   2          }
 165   1      }
 166          static void updateLocal(void)
 167          {
 168   1          static bool high_flag[4] = {false};
 169   1          uint8_t i = 0;
 170   1          uint8_t last_key = h595_val;
 171   1          uint8_t relays[4] = {0};
 172   1          dev_def.update_local_cnt++;
 173   1          if(dev_def.update_local_cnt == update_time)
 174   1          {
 175   2              relays[0] = (uint8_t)RELAY1;
 176   2              relays[1] = (uint8_t)RELAY2;
 177   2              relays[2] = (uint8_t)RELAY3;
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 4   

 178   2              relays[3] = (uint8_t)RELAY4;
 179   2              for(i = 0; i < 4; i++)
 180   2              {
 181   3                  if(dev_def.dev_channel[i].update_flag)
 182   3                  {
 183   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 184   4                      {
 185   5                          high_flag[i] = true;
 186   5                          h595_val &= ~key_array[i];
 187   5                      }
 188   4                      else
 189   4                      {
 190   5                          dev_def.dev_channel[i].update_flag = false;
 191   5                      }
 192   4                  }
 193   3              }
 194   2              if(h595_val != last_key)
 195   2              {
 196   3                  SendTo595(h595_val);
 197   3              }
 198   2          }
 199   1          else if(dev_def.update_local_cnt >= update_time + 1)
 200   1          {
 201   2              dev_def.update_local_cnt = 0;
 202   2              for(i = 0; i < 4; i++)
 203   2              {
 204   3                  if(high_flag[i] == true)
 205   3                  {
 206   4                      h595_val |= key_array[i];
 207   4                      high_flag[i] = false;
 208   4                  }
 209   3              }
 210   2              if(h595_val != last_key)
 211   2              {
 212   3                  SendTo595(h595_val);
 213   3              }
 214   2          }
 215   1      
 216   1          
 217   1      }
 218          void dealLogic(void)
 219          {
 220   1          if(key_scan_flag)
 221   1          {
 222   2              key_scan_flag = false;
 223   2              keyScan();
 224   2          }
 225   1          if(syn_app_flag)
 226   1          {
 227   2              syn_app_flag = false;
 228   2              syncApp();
 229   2          }
 230   1          if(update_local_flag)
 231   1          {
 232   2              update_local_flag = false;
 233   2              updateLocal();//要在同步APP之后
 234   2          }
 235   1      }
 236          void saveModeToFlash(void)
 237          {
 238   1          if(save_mode_flag)
 239   1          {
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 5   

 240   2                      flash_data[0] = dev_def.lock;
 241   2                      flash_data[1] = (uint8_t)dev_def.dev_channel[0].channel_mode;
 242   2                      flash_data[2] = (uint8_t)dev_def.dev_channel[1].channel_mode;
 243   2                      flash_data[3] = (uint8_t)dev_def.dev_channel[2].channel_mode;
 244   2                      flash_data[4] = (uint8_t)dev_def.dev_channel[3].channel_mode;
 245   2                      flashWrite();
 246   2                      save_mode_flag = false;
 247   2          }
 248   1      }
 249          void dealRemoteLed(void)
 250          {
 251   1          static uint8_t remote_led_cnt = 0;
 252   1          remote_led_cnt++;
 253   1          if(dev_def.remote)
 254   1              {
 255   2              if(remote_led_cnt >= 100)
 256   2              {
 257   3                  remote_led_cnt = 0;
 258   3                  MODE_LED = !MODE_LED;
 259   3              }
 260   2              }
 261   1              else
 262   1              {
 263   2              if(dev_def.lock)
 264   2              {
 265   3                  MODE_LED = 1;
 266   3              }
 267   2              else
 268   2              {
 269   3                  MODE_LED = 0;
 270   3              }
 271   2              }
 272   1      }
 273          void dealRemote(void)
 274          {
 275   1              if(deal_remote_flag)
 276   1              {
 277   2                      deal_remote_flag = false;
 278   2                      analyzeRfData();
 279   2                      dealRemoteLed();
 280   2              }
 281   1      }
 282          static void modeInit(void)
 283          {
 284   1              flashRead();
 285   1              dev_def.lock = flash_data[0];
 286   1              dev_def.dev_channel[0].channel_mode = flash_data[1];
 287   1              dev_def.dev_channel[1].channel_mode = flash_data[2];
 288   1              dev_def.dev_channel[2].channel_mode = flash_data[3];
 289   1              dev_def.dev_channel[3].channel_mode = flash_data[4];
 290   1          if(dev_def.lock == 0xff 
 291   1              || dev_def.dev_channel[0].channel_mode == 0xff
 292   1              || dev_def.dev_channel[1].channel_mode == 0xff
 293   1              || dev_def.dev_channel[2].channel_mode == 0xff
 294   1              || dev_def.dev_channel[3].channel_mode == 0xff)
 295   1          {
 296   2              dev_def.lock = false;
 297   2              dev_def.dev_channel[0].channel_mode = DEV_SELFLOCK;
 298   2              dev_def.dev_channel[1].channel_mode = DEV_SELFLOCK;
 299   2              dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 300   2              dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 301   2          }
C51 COMPILER V9.01   LOGIC                                                                 07/17/2017 16:18:52 PAGE 6   

 302   1          if(dev_def.lock)
 303   1          {
 304   2              MODE_LED = 1;
 305   2          }
 306   1          else
 307   1          {
 308   2              MODE_LED = 0;
 309   2          }
 310   1      }
 311          void logicInit(void)
 312          {
 313   1          modeInit();
 314   1          h595Init();
 315   1          SendTo595(0x0f);
 316   1          ledInit();   
 317   1              keyInit();
 318   1          relayInit();
 319   1      #if 1
 320   1              captureInit();
 321   1              timer1Init();
 322   1      #endif
 323   1          timer0Init();
 324   1      }
 325          void SendTo595(uint8_t val)
 326          {
 327   1              char i=0;
 328   1              uint8_t temp = val;
 329   1              EA = 0;
 330   1              for(i = 0; i < 8; i++)
 331   1              {
 332   2                      SER = temp>>7;
 333   2                      temp= temp<<1;
 334   2                      SCK = 0;
 335   2                      _nop_();
 336   2                      SCK = 1;
 337   2              }
 338   1              RCK = 0;
 339   1              _nop_();
 340   1              RCK = 1;
 341   1              SER = 0;
 342   1              EA = 1;
 343   1      }
 344          
 345          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1085    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     25    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
