C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 18:42:00 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LOGIC
OBJECT MODULE PLACED IN logic.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\logic\logic.c BROWSE INCDIR(.\code\key;.\code\logic;.\co
                    -de\timer;.\code\driver;.\code\led;.\code\common) DEBUG OBJECTEXTEND PRINT(.\logic.lst) OBJECT(logic.obj)

line level    source

   1          #include <intrins.h>
   2          #include "logic.h"
   3          #include "N76E003.h"
   4          #include "key.h"
   5          #include "led.h"
   6          #include "timer.h"
   7          #include "key_driver.h"
   8          
   9          sbit RCK = P1^7;
  10          sbit SCK = P1^6;
  11          sbit SER = P3^0;
  12          
  13          bool led_blink_flag = false;
  14          bool key_scan_flag = false;
  15          bool update_local_flag = false;
  16          bool deal_jogging = false;
  17          bool deal_lock = false;
  18          bool syn_app_flag = false;
  19          
  20          uint8_t code relay_array[4] = {0x80,0x40,0x20,0x10};
  21          uint8_t code key_array[4] = {0x04,0x02,0x01,0x08};
  22          
  23          DevDef xdata dev_def = {0};
  24          static void h595Init(void)
  25          {
  26   1          //初始化P16 P17 P30为推挽输出
  27   1          P1M1 &= 0x3f;
  28   1              P1M2 |= 0Xc0;
  29   1              P3M1 &= 0xfe;
  30   1          P3M2 |= 0x01;
  31   1          SER = 1;
  32   1      }
  33          static void relayInit(void)
  34          {
  35   1          P0M1 |= 0x0f;//初始化relay脚 P00 -> P03     为输入
  36   1              P0M2 &= 0Xf0;  
  37   1      }
  38          static void syncApp(void)
  39          {
  40   1          uint8_t last_key = h595_val;
  41   1          uint8_t relays[4] = {0};
  42   1          uint8_t i = 0;
  43   1          relays[0] = RELAY1;
  44   1          relays[1] = RELAY2;
  45   1          relays[2] = RELAY3;
  46   1          relays[3] = RELAY4;
  47   1          if(dev_def.lock)
  48   1          {
  49   2              static uint8_t lock_channel = 0;
  50   2              static uint8_t last_lock_channel = 0;
  51   2              static uint8_t last_relay_val[4] = {0};
  52   2              if(dev_def.dev_channel[0].update_flag 
  53   2                  || dev_def.dev_channel[1].update_flag 
  54   2                  || dev_def.dev_channel[2].update_flag
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 18:42:00 PAGE 2   

  55   2                  || dev_def.dev_channel[3].update_flag)
  56   2              {
  57   3                  return;
  58   3              }
  59   2              for(i = 0; i < 4;i++)
  60   2              {
  61   3                  if(relays[i] != last_relay_val[i] && relays[i] == 1)
  62   3                  {
  63   4                      lock_channel = i + 1;
  64   4                  }
  65   3                  last_relay_val[i] = relays[i];
  66   3              }
  67   2              if(last_lock_channel != lock_channel)
  68   2              {
  69   3                  last_lock_channel = lock_channel;
  70   3                  for(i = 0; i < 4; i++)
  71   3                  {
  72   4                      if(lock_channel == (i + 1))
  73   4                      {
  74   5                          h595_val &= 0x0f;
  75   5                          h595_val |= relay_array[i];
  76   5                      }
  77   4                  }
  78   3                  dev_def.dev_channel[0].update_flag = true;
  79   3                  dev_def.dev_channel[1].update_flag = true;
  80   3                  dev_def.dev_channel[2].update_flag = true;
  81   3                  dev_def.dev_channel[3].update_flag = true;
  82   3                  dev_def.update_local_cnt = 0;
  83   3              }
  84   2              else
  85   2              {
  86   3                  if(relays[lock_channel - 1])
  87   3                  {
  88   4                      if(!(h595_val & relay_array[lock_channel - 1]))
  89   4                      {
  90   5                          h595_val |= relay_array[lock_channel - 1];
  91   5                          dev_def.dev_channel[0].update_flag = true;
  92   5                          dev_def.dev_channel[1].update_flag = true;
  93   5                          dev_def.dev_channel[2].update_flag = true;
  94   5                          dev_def.dev_channel[3].update_flag = true;
  95   5                          dev_def.update_local_cnt = 0;
  96   5                      }
  97   4                     
  98   4                  }
  99   3                  else
 100   3                  {
 101   4                      if(h595_val & relay_array[lock_channel - 1])
 102   4                      {
 103   5                          h595_val &= ~relay_array[lock_channel - 1];
 104   5                          dev_def.dev_channel[0].update_flag = true;
 105   5                          dev_def.dev_channel[1].update_flag = true;
 106   5                          dev_def.dev_channel[2].update_flag = true;
 107   5                          dev_def.dev_channel[3].update_flag = true;
 108   5                          dev_def.update_local_cnt = 0;
 109   5                      }
 110   4                  }
 111   3              }
 112   2          }
 113   1          else
 114   1          {
 115   2              for(i =  0; i < 4; i++)
 116   2              {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 18:42:00 PAGE 3   

 117   3                  if(dev_def.dev_channel[i].channel_mode == DEV_JOGGING)
 118   3                  {
 119   4                      dev_def.dev_channel[i].timer_cnt++;
 120   4                      if((h595_val & relay_array[i]))//如果relay1是按下的
 121   4                      {
 122   5                          if(dev_def.dev_channel[i].get_status == false)
 123   5                          {
 124   6                              dev_def.dev_channel[i].timer_cnt = 0;
 125   6                              dev_def.dev_channel[i].get_status = true;
 126   6                          }
 127   5                          if(dev_def.dev_channel[i].timer_cnt >= 7)
 128   5                          {
 129   6                              dev_def.dev_channel[i].timer_cnt = 0;
 130   6                              dev_def.dev_channel[i].get_status = false;
 131   6                              h595_val &= (~relay_array[i]);//关掉relay1
 132   6                              dev_def.dev_channel[i].update_flag = true;//允许更新标志位
 133   6                              dev_def.update_local_cnt = 0;
 134   6                          }
 135   5                      }
 136   4                  }
 137   3                  if(!dev_def.dev_channel[i].update_flag)
 138   3                  {
 139   4                      if(relays[i])
 140   4                      {
 141   5                          h595_val |= relay_array[i];
 142   5                      }
 143   4                      else
 144   4                      {
 145   5                          h595_val &= (~relay_array[i]);
 146   5                      }
 147   4                  }
 148   3              }
 149   2          }
 150   1          if(h595_val != last_key)
 151   1          {
 152   2              SendTo595(h595_val);
 153   2          }
 154   1      }
 155          static void updateLocal(void)
 156          {
 157   1          static bool high_flag[4] = {false};
 158   1          uint8_t i = 0;
 159   1          uint8_t last_key = h595_val;
 160   1          uint8_t relays[4] = {0};
 161   1          dev_def.update_local_cnt++;
 162   1          if(dev_def.update_local_cnt == 10)
 163   1          {
 164   2              relays[0] = (uint8_t)RELAY1;
 165   2              relays[1] = (uint8_t)RELAY2;
 166   2              relays[2] = (uint8_t)RELAY3;
 167   2              relays[3] = (uint8_t)RELAY4;
 168   2              for(i = 0; i < 4; i++)
 169   2              {
 170   3                  if(dev_def.dev_channel[i].update_flag)
 171   3                  {
 172   4                      if((relays[i] << (7 - i)) != (h595_val & relay_array[i]))
 173   4                      {
 174   5                          high_flag[i] = true;
 175   5                          h595_val &= ~key_array[i];
 176   5                      }
 177   4                      else
 178   4                      {
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 18:42:00 PAGE 4   

 179   5                          dev_def.dev_channel[i].update_flag = false;
 180   5                      }
 181   4                  }
 182   3              }
 183   2              if(h595_val != last_key)
 184   2              {
 185   3                  MODE_LED = !MODE_LED;
 186   3                  SendTo595(h595_val);
 187   3              }
 188   2          }
 189   1          else if(dev_def.update_local_cnt >= 11)
 190   1          {
 191   2              dev_def.update_local_cnt = 0;
 192   2              for(i = 0; i < 4; i++)
 193   2              {
 194   3                  if(high_flag[i] == true)
 195   3                  {
 196   4                      h595_val |= key_array[i];
 197   4                      high_flag[i] = false;
 198   4                  }
 199   3              }
 200   2              if(h595_val != last_key)
 201   2              {
 202   3                  MODE_LED = !MODE_LED;
 203   3                  SendTo595(h595_val);
 204   3              }
 205   2          }
 206   1      
 207   1          
 208   1      }
 209          void dealLogic(void)
 210          {
 211   1          if(key_scan_flag)
 212   1          {
 213   2              key_scan_flag = false;
 214   2              keyScan();
 215   2          }
 216   1          if(syn_app_flag)
 217   1          {
 218   2              syn_app_flag = false;
 219   2              syncApp();
 220   2          }
 221   1          if(update_local_flag)
 222   1          {
 223   2              update_local_flag = false;
 224   2              updateLocal();//要在同步APP之后
 225   2          }
 226   1          
 227   1      }
 228          void logicInit(void)
 229          {
 230   1          h595Init();
 231   1          SendTo595(0x0f);
 232   1          ledInit();   
 233   1              keyInit();
 234   1          relayInit();
 235   1          timer0Init();
 236   1          dev_def.dev_channel[0].channel_mode = DEV_JOGGING;
 237   1          dev_def.dev_channel[1].channel_mode = DEV_JOGGING;
 238   1          dev_def.dev_channel[2].channel_mode = DEV_SELFLOCK;
 239   1          dev_def.dev_channel[3].channel_mode = DEV_SELFLOCK;
 240   1          dev_def.lock = false;
C51 COMPILER V9.01   LOGIC                                                                 07/03/2017 18:42:00 PAGE 5   

 241   1          MODE_LED = 0;
 242   1      }
 243          void SendTo595(uint8_t val)
 244          {
 245   1              char i=0;
 246   1              uint8_t temp = val;
 247   1              EA = 0;
 248   1              for(i = 0; i < 8; i++)
 249   1              {
 250   2                      SER = temp>>7;
 251   2                      temp= temp<<1;
 252   2                      SCK = 0;
 253   2                      _nop_();
 254   2                      SCK = 1;
 255   2              }
 256   1              RCK = 0;
 257   1              _nop_();
 258   1              RCK = 1;
 259   1              SER = 0;
 260   1              EA = 1;
 261   1      }
 262          
 263          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    867    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     22    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
