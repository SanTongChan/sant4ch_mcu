C51 COMPILER V9.01   REMOTE                                                                07/17/2017 16:18:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE REMOTE
OBJECT MODULE PLACED IN remote.obj
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE code\remote\remote.c BROWSE INCDIR(.\code\key;.\code\logic;.\
                    -code\timer;.\code\driver;.\code\led;.\code\common;.\code\flash;.\code\remote) DEBUG OBJECTEXTEND PRINT(.\remote.lst) OBJ
                    -ECT(remote.obj)

line level    source

   1          #include "remote.h"
   2          #include "N76E003.h"
   3          #include "led.h"
   4          #if 1
   5          sbit RF_PIN = P1^5;
   6          
   7          typedef struct
   8          {
   9                  uint8_t end_flag;
  10                  uint8_t sync_flag;
  11                  uint16_t sync_time;
  12                  uint16_t rf_data[48];
  13          }RecvData;
  14          static RecvData xdata recv_data = {0};
  15          
  16          IrData xdata ir_data = {0};
  17          
  18          static void getCaptureVal(uint16_t capture_value)
  19          {
  20   1              static uint8_t cnt = 0;
  21   1              if(!recv_data.sync_flag)
  22   1              {
  23   2                      if(capture_value >= 250 && RF_PIN == 1)
  24   2                      {
  25   3                              recv_data.sync_time = capture_value;
  26   3                              recv_data.sync_flag = true;
  27   3                              
  28   3                      }
  29   2              }
  30   1              else
  31   1              {
  32   2                      if(recv_data.sync_time > (capture_value * 5))
  33   2                      {
  34   3                              recv_data.rf_data[cnt] = capture_value;
  35   3                              cnt++;
  36   3                      }
  37   2                      else
  38   2                      {
  39   3                              recv_data.sync_flag = false;
  40   3                              cnt = 0;
  41   3                      }
  42   2                      if(cnt >= 48)
  43   2                      {
  44   3                              cnt = 0;
  45   3                              recv_data.end_flag = true;
  46   3                              recv_data.sync_flag = false;
  47   3                      }
  48   2              }
  49   1      
  50   1      }
  51          void analyzeRfData(void)
  52          {
  53   1              uint8_t i = 0;
C51 COMPILER V9.01   REMOTE                                                                07/17/2017 16:18:52 PAGE 2   

  54   1              uint32_t temp = 0;
  55   1              uint16_t unit_time = 0;
  56   1              uint16_t temp_time = 0;
  57   1              uint16_t threshold_time = 0;
  58   1              uint16_t sync_threshold = 0;
  59   1              uint16_t short_time = 0;
  60   1              uint16_t long_time = 0;
  61   1              if(recv_data.end_flag == true)
  62   1              {
  63   2                      recv_data.end_flag = false;
  64   2                      if(ir_data.cnt == 0)
  65   2                      {
  66   3                              ir_data.high_time = recv_data.rf_data[0];
  67   3                              ir_data.low_time = recv_data.rf_data[1];
  68   3                              ir_data.sync_time = recv_data.sync_time;
  69   3                      }
  70   2                      unit_time = ir_data.high_time + ir_data.low_time;
  71   2                      threshold_time = unit_time / 5;
  72   2                      sync_threshold = ir_data.sync_time / 5;
  73   2                      for(i = 0; i < 48; i = i + 2)
  74   2                      {
  75   3                              temp_time = recv_data.rf_data[i] + recv_data.rf_data[i + 1];
  76   3                              if((temp_time > unit_time + threshold_time)
  77   3                                      || (temp_time < unit_time - threshold_time))
  78   3                              {
  79   4                                      ir_data.timer_cnt++;
  80   4                                      return;
  81   4                              }
  82   3                              if(recv_data.rf_data[i] > recv_data.rf_data[i + 1])
  83   3                              {
  84   4                                      temp = (temp << 1) | 0x01;
  85   4                                      short_time += recv_data.rf_data[i + 1];
  86   4                                      long_time += recv_data.rf_data[i];
  87   4                              }
  88   3                              else if(recv_data.rf_data[i] < recv_data.rf_data[i + 1])
  89   3                              {
  90   4                                      temp = temp << 1;
  91   4                                      long_time += recv_data.rf_data[i + 1];
  92   4                                      short_time += recv_data.rf_data[i];
  93   4                              }
  94   3                              else
  95   3                              {
  96   4                                      ir_data.timer_cnt++;
  97   4                                      return;
  98   4                              }
  99   3                      }
 100   2                      if(!(ir_data.sync_time < threshold_time + recv_data.sync_time
 101   2                              && ir_data.sync_time > recv_data.sync_time - threshold_time
 102   2                              && temp == ir_data.ir_data))
 103   2                      {
 104   3                              ir_data.sync_time = recv_data.sync_time;
 105   3                              ir_data.ir_data = temp;
 106   3                              ir_data.cnt = 1;
 107   3                              ir_data.timer_cnt = 0;
 108   3                              ir_data.low_time = (uint16_t)((short_time / 24) + 0.5);
 109   3                              ir_data.high_time = (uint16_t)((long_time / 24) + 0.5);
 110   3                              RF_LED = !RF_LED;
 111   3                      }
 112   2                      else
 113   2                      {
 114   3                              ir_data.cnt++;
 115   3                              ir_data.timer_cnt = 0;
C51 COMPILER V9.01   REMOTE                                                                07/17/2017 16:18:52 PAGE 3   

 116   3                      }
 117   2              }
 118   1              else
 119   1              {
 120   2                      ir_data.timer_cnt++;
 121   2              }
 122   1      }
 123          static void Timer2Init(void)
 124          {
 125   1              T2CON&=~0x01;
 126   1              T2MOD &= 0X0F;
 127   1              T2MOD|=0xD0;
 128   1              T2MOD|=0X08;    
 129   1      
 130   1              CAPCON0|=0x10;
 131   1              CAPCON1|=0x03;
 132   1              CAPCON1&=0xfe;
 133   1              //CAPCON2|=0x10;
 134   1              CAPCON3&=0xF0;
 135   1              CAPCON3|=0x08;
 136   1      }
 137          static void captureIOInit(void)
 138          {
 139   1              P1M1 &= 0xDF;
 140   1              P1M2 &= 0XDF;
 141   1      }
 142          void captureInit(void)
 143          {
 144   1              captureIOInit();
 145   1              Timer2Init();
 146   1              EIE |= 0X84;
 147   1              TR2 = 1;
 148   1      }
 149          void Capture_ISR (void) interrupt 12
 150          {
 151   1              uint16_t capture_val = 0;
 152   1              if(CAPCON0 & 0X01 )
 153   1              {
 154   2                      CAPCON0 &= ~0x01;
 155   2                      capture_val = C0H << 8 | C0L;   
 156   2                      getCaptureVal(capture_val);        
 157   2                      
 158   2              }
 159   1      }
 160          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    937    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    113    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
